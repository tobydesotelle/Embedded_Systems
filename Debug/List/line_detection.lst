###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          17/Nov/2022  23:51:36
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\line_detection.c
#    Command line  =  
#        -f C:\Users\TOBIAS~1\AppData\Local\Temp\EW202B.tmp ("C:\Users\Tobias
#        Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\line_detection.c" -lC
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List" -o
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj" --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I
#        ./ --core=430X --data_model=small -Ohz --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List\line_detection.lst
#    Object file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj\line_detection.r43
#
###############################################################################

C:\Users\Tobias Desotelle\OneDrive - UNC Asheville\Documents\GitHub\Embedded_Systems\line_detection.c
      1          #include "macros.h"
      2          #define DECTECTION_THRESHOLD            (100)
      3          #define DECTECTION_TOLERANCE            (10)
      4          
      5          
      6          #define FULL_DETECTION                  (110)
      7          #define STRONG_DETECTION                (100)
      8          #define SLIGHT_DETECTION                (30)
      9          #define BASE_READING                    (20)
     10          
     11          #define SLIGHT_DETECTION_TOLERANCE      (30)
     12          
     13          
     14          #define BASE_READING_TOLERANCE          (20)
     15          
     16          
     17          #define DTH                             (DECTECTION_THRESHOLD+DECTECTION_TOLERANCE)//DECTECTION_THRESHOLD_LOW
     18          #define DTL                             (DECTECTION_THRESHOLD-DECTECTION_TOLERANCE)//DECTECTION_THRESHOLD_HIGH
     19          
     20          #define ERROR_LIMITS                          (1000)
     21          
     22          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          unsigned short line_detection;
   \                     line_detection:
   \   000000                DS8 2
     24          extern unsigned int ADC_Left_Detect;
     25          extern unsigned int ADC_Right_Detect;
     26          extern unsigned int V_Thumb;
     27          
     28          
     29          

   \                                 In  segment CODE, align 2
     30          float measurment(){//This is the measurment value for the pid contoller
   \                     measurment:
   \   000000   1B15         PUSHM.W #0x2, R11
     31          //  if(ADC_Left_Detect<=BASE_READING);//
     32          //  if(ADC_Right_Detect<=BASE_READING);
     33            return (float)ADC_Left_Detect - ADC_Right_Detect ;//+ PID_SETPOINT;
   \   000002   1C42....     MOV.W   &ADC_Left_Detect, R12
   \   000006   0D43         MOV.W   #0x0, R13
   \   000008   ........     CALLA   #_Cast32uto32f
   \   00000C   0A4C         MOV.W   R12, R10
   \   00000E   0B4D         MOV.W   R13, R11
   \   000010   1C42....     MOV.W   &ADC_Right_Detect, R12
   \   000014   0D43         MOV.W   #0x0, R13
   \   000016   ........     CALLA   #_Cast32uto32f
   \   00001A   0E4C         MOV.W   R12, R14
   \   00001C   0F4D         MOV.W   R13, R15
   \   00001E   0C4A         MOV.W   R10, R12
   \   000020   0D4B         MOV.W   R11, R13
   \   000022   ........     CALLA   #_Sub32f
   \   000026   1A17         POPM.W  #0x2, R11
   \   000028   1001         RETA
     34          }
     35          
     36          

   \                                 In  segment CODE, align 2
     37          void set_line_bit(unsigned short level_detection){
   \                     set_line_bit:
     38            if(level_detection>L_CLEAR)line_detection &= L_CLEAR;
   \   000000   5F42....     MOV.B   &line_detection, R15
   \   000004   3C901000     CMP.W   #0x10, R12
   \   000008   0328         JNC     ??set_line_bit_1
   \   00000A   3FF00F00     AND.W   #0xf, R15
   \   00000E   023C         JMP     ??set_line_bit_0
     39            else line_detection &= R_CLEAR;
   \                     ??set_line_bit_1:
   \   000010   3FF0F000     AND.W   #0xf0, R15
     40            line_detection |= level_detection;
   \                     ??set_line_bit_0:
   \   000014   0FDC         BIS.W   R12, R15
   \   000016   824F....     MOV.W   R15, &line_detection
     41          }
   \   00001A   1001         RETA
     42          

   \                                 In  segment CODE, align 2
     43          void left_detector_process(){
   \                     left_detector_process:
     44            if(ADC_Right_Detect<=BASE_READING)set_line_bit(R_BASE);
   \   000000   1F42....     MOV.W   &ADC_Right_Detect, R15
   \   000004   3F901500     CMP.W   #0x15, R15
   \   000008   032C         JC      ??left_detector_process_0
   \   00000A   1C43         MOV.W   #0x1, R12
   \   00000C   ........     BRA     #set_line_bit
     45            else if(ADC_Right_Detect<=SLIGHT_DETECTION)set_line_bit(R_SLIGHT);
   \                     ??left_detector_process_0:
   \   000010   3F901F00     CMP.W   #0x1f, R15
   \   000014   032C         JC      ??left_detector_process_1
   \   000016   2C43         MOV.W   #0x2, R12
   \   000018   ........     BRA     #set_line_bit
     46            else if(ADC_Right_Detect<=STRONG_DETECTION)set_line_bit(R_STRONG);
   \                     ??left_detector_process_1:
   \   00001C   3F906500     CMP.W   #0x65, R15
   \   000020   032C         JC      ??left_detector_process_2
   \   000022   2C42         MOV.W   #0x4, R12
   \   000024   ........     BRA     #set_line_bit
     47            else if(ADC_Right_Detect>STRONG_DETECTION)set_line_bit(R_FULL);
   \                     ??left_detector_process_2:
   \   000028   3C42         MOV.W   #0x8, R12
   \   00002A   ........     BRA     #set_line_bit
     48          }

   \                                 In  segment CODE, align 2
     49          void right_detector_process(){
   \                     right_detector_process:
     50            if(ADC_Left_Detect<=BASE_READING)set_line_bit(L_BASE);
   \   000000   1F42....     MOV.W   &ADC_Left_Detect, R15
   \   000004   3F901500     CMP.W   #0x15, R15
   \   000008   042C         JC      ??right_detector_process_0
   \   00000A   3C401000     MOV.W   #0x10, R12
   \   00000E   ........     BRA     #set_line_bit
     51            else if(ADC_Left_Detect<=SLIGHT_DETECTION)set_line_bit(L_SLIGHT);
   \                     ??right_detector_process_0:
   \   000012   3F901F00     CMP.W   #0x1f, R15
   \   000016   042C         JC      ??right_detector_process_1
   \   000018   3C402000     MOV.W   #0x20, R12
   \   00001C   ........     BRA     #set_line_bit
     52            else if(ADC_Left_Detect<=STRONG_DETECTION)set_line_bit(L_STRONG);
   \                     ??right_detector_process_1:
   \   000020   3F906500     CMP.W   #0x65, R15
   \   000024   042C         JC      ??right_detector_process_2
   \   000026   3C404000     MOV.W   #0x40, R12
   \   00002A   ........     BRA     #set_line_bit
     53            else if(ADC_Left_Detect>STRONG_DETECTION)set_line_bit(L_FULL);
   \                     ??right_detector_process_2:
   \   00002E   3C408000     MOV.W   #0x80, R12
   \   000032   ........     BRA     #set_line_bit
     54          }
     55          

   \                                 In  segment CODE, align 2
     56          void process_detectors(){
   \                     process_detectors:
     57            left_detector_process();
   \   000000   ........     CALLA   #left_detector_process
     58            right_detector_process();
   \   000004   ........     BRA     #right_detector_process
     59          }
     60          

   \                                 In  segment CODE, align 2
     61          unsigned short strong_detect(){
   \                     strong_detect:
     62            if(line_detection==0x88){
   \   000000   B2908800.... CMP.W   #0x88, &line_detection
   \   000006   0C43         MOV.W   #0x0, R12
   \   000008   22B3         BIT.W   #0x2, SR
   \   00000A   0C63         ADDC.W  #0x0, R12
     63              return 1;
   \   00000C   1001         RETA
     64            }
     65            return 0;
     66          }
     67          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   left_detector_process
        0   -> set_line_bit
      8   measurment
        8 _Cast32uto32f
        8 _Sub32f
      4   process_detectors
        4   -> left_detector_process
        0   -> right_detector_process
      4   right_detector_process
        0   -> set_line_bit
      4   set_line_bit
      4   strong_detect


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      46  left_detector_process
       2  line_detection
      42  measurment
       8  process_detectors
      54  right_detector_process
      28  set_line_bit
      14  strong_detect

 
 192 bytes in segment CODE
   2 bytes in segment DATA16_Z
 
 192 bytes of CODE memory
   2 bytes of DATA memory

Errors: none
Warnings: none
