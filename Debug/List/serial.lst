###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          13/Nov/2022  22:07:39
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\serial.c
#    Command line  =  
#        -f C:\Users\TOBIAS~1\AppData\Local\Temp\EWDB4E.tmp ("C:\Users\Tobias
#        Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\serial.c" -lC
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List" -o
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I
#        ./ --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List\serial.lst
#    Object file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj\serial.r43
#
###############################################################################

C:\Users\Tobias Desotelle\OneDrive - UNC Asheville\Documents\GitHub\Embedded_Systems\serial.c
      1          #include "macros.h"

   \                                 In  segment DATA16_AN, at 0x500
   \   union <unnamed> _A_UCA0CTLW0_L
   \                     _A_UCA0CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x506
   \   union <unnamed> _A_UCA0BRW_L
   \                     _A_UCA0BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x508
   \   union <unnamed> _A_UCA0MCTLW_L
   \                     _A_UCA0MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50e
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51e
   \   union <unnamed> _A_UCA0IV_L
   \                     _A_UCA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x580
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x586
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x588
   \   union <unnamed> _A_UCA1MCTLW_L
   \                     _A_UCA1MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58c
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58e
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59a
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59e
   \   union <unnamed> _A_UCA1IV_L
   \                     _A_UCA1IV_L:
   \   000000                DS8 2
      2          
      3          extern volatile unsigned short serial_bits;
      4          #define eUCA0_rx                ()
      5          
      6          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      7          volatile unsigned int usb_rx_ring_wr;
   \                     usb_rx_ring_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      8          volatile char USB_Char_Rx[SMALL_RING_SIZE];
   \                     USB_Char_Rx:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      9          char temp[2];
   \                     temp:
   \   000000                DS8 2
     10          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     11          char process_buf_tx[NUM_PROCESS_BUF][PROCESS_BUF_LENGTH];// 
   \                     process_buf_tx:
   \   000000                DS8 33

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     12          int count=0;
   \                     count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     13          char RING_BUF_A0[SMALL_RING_SIZE];
   \                     RING_BUF_A0:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     14          char *rx_start;
   \                     rx_start:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          char TX_A1[SMALL_RING_SIZE];
   \                     TX_A1:
   \   000000                DS8 16
     16          //char *TX_char=process_buf_rx; 
     17          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     18          char *RX_write=RING_BUF_A0;
   \                     RX_write:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for RX_write>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          char *RX_read;
   \                     RX_read:
   \   000000                DS8 2
     20          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          char *Tx_String;
   \                     Tx_String:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          unsigned int i;
   \                     i:
   \   000000                DS8 2
     23          
     24          #define Send_UCA0        (0x00)
     25          #define Send_UCA1        (0x01)

   \                                 In  segment CODE, align 2
     26          void send(char *string, char port){
   \                     send:
     27            i=0;
   \   000000   8243....     MOV.W   #0x0, &i
     28            Tx_String = string;
   \   000004   824C....     MOV.W   R12, &Tx_String
     29            switch(port){
   \   000008   4E4D         MOV.B   R13, R14
   \   00000A   4E83         SUB.B   #0x0, R14
   \   00000C   0324         JEQ     ??send_0
   \   00000E   5E83         SUB.B   #0x1, R14
   \   000010   0424         JEQ     ??send_1
   \   000012   1001         RETA
     30            case Send_UCA0:
     31              UCA0IE |= UCTXIE;
   \                     ??send_0:
   \   000014   A2D31A05     BIS.W   #0x2, &0x51a
     32              break;
   \   000018   1001         RETA
     33            case Send_UCA1:
     34              UCA1IE |= UCTXIE;
   \                     ??send_1:
   \   00001A   A2D39A05     BIS.W   #0x2, &0x59a
     35              //UCA1TXBUF = Tx_String[i];
     36              break;
     37            }
     38            
     39          }
   \   00001E   1001         RETA
   \   000020                REQUIRE _A_UCA0IE_L
   \   000020                REQUIRE _A_UCA1IE_L
     40          

   \                                 In  segment CODE, align 2
     41          void Init_Serial_UCA0(char speed){
   \                     Init_Serial_UCA0:
     42          
     43            switch(speed){
   \   000000   4E4C         MOV.B   R12, R14
   \   000002   4E83         SUB.B   #0x0, R14
   \   000004   0324         JEQ     ??Init_Serial_UCA0_0
   \   000006   5E83         SUB.B   #0x1, R14
   \   000008   2424         JEQ     ??Init_Serial_UCA0_1
   \   00000A   1001         RETA
     44            case BAUD115200:
     45            //------------------------------------------------------------------------------
     46            // TX error (%) RX error (%)
     47            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
     48            // 8000000 4800 1 104 2 0xD6 -0.08 0.04 -0.10 0.14
     49            // 8000000 9600 1 52 1 0x49 -0.08 0.04 -0.10 0.14
     50            // 8000000 19200 1 26 0 0xB6 -0.08 0.16 -0.28 0.20
     51            // 8000000 57600 1 8 10 0xF7 -0.32 0.32 -1.00 0.36
     52            // 8000000 115200 1 4 5 0x55 -0.80 0.64 -1.12 1.76
     53            // 8000000 460800 0 17 0 0x4A -2.72 2.56 -3.76 7.28
     54            //------------------------------------------------------------------------------
     55            // Configure eUSCI_A0 for UART mode
     56            UCA0CTLW0 = 0;
   \                     ??Init_Serial_UCA0_0:
   \   00000C   82430005     MOV.W   #0x0, &0x500
     57            UCA0CTLW0 |= UCSWRST ; // Put eUSCI in reset
   \   000010   92D30005     BIS.W   #0x1, &0x500
     58            UCA0CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK
   \   000014   B2D080000005 BIS.W   #0x80, &0x500
     59            UCA0CTLW0 &= ~UCMSB; // MSB, LSB select
   \   00001A   B2C000200005 BIC.W   #0x2000, &0x500
     60            UCA0CTLW0 &= ~UCSPB; // UCSPB = 0(1 stop bit) OR 1(2 stop bits)
   \   000020   B2C000080005 BIC.W   #0x800, &0x500
     61            UCA0CTLW0 &= ~UCPEN; // No Parity
   \   000026   B2C000800005 BIC.W   #0x8000, &0x500
     62            UCA0CTLW0 &= ~UCSYNC;
   \   00002C   B2C000010005 BIC.W   #0x100, &0x500
     63            UCA0CTLW0 &= ~UC7BIT;
   \   000032   B2C000100005 BIC.W   #0x1000, &0x500
     64            UCA0CTLW0 |= UCMODE_0;
   \   000038   924200050005 MOV.W   &0x500, &0x500
     65            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
     66            // 8000000 115200 1 4 5 0x55 -0.80 0.64 -1.12 1.76
     67            // UCA?MCTLW = UCSx + UCFx + UCOS16
     68            UCA0BRW = 4 ; // 115,200 baud
   \   00003E   A2420605     MOV.W   #0x4, &0x506
     69            UCA0MCTLW = 0x5551 ;
   \   000042   B24051550805 MOV.W   #0x5551, &0x508
     70            UCA0CTLW0 &= ~UCSWRST ; // release from reset
   \   000048   92C30005     BIC.W   #0x1, &0x500
     71            //UCA0TXBUF = 0x00; // Prime the Pump
     72            UCA0IE |= UCRXIE; // Enable RX interrupt
   \   00004C   92D31A05     BIS.W   #0x1, &0x51a
     73            break;
   \   000050   1001         RETA
     74            case BAUD460800:
     75            UCA0CTLW0 = 0;
   \                     ??Init_Serial_UCA0_1:
   \   000052   82430005     MOV.W   #0x0, &0x500
     76            UCA0CTLW0 |= UCSWRST ; // Put eUSCI in reset
   \   000056   92D30005     BIS.W   #0x1, &0x500
     77            UCA0CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK
   \   00005A   B2D080000005 BIS.W   #0x80, &0x500
     78            UCA0CTLW0 &= ~UCMSB; // MSB, LSB select
   \   000060   B2C000200005 BIC.W   #0x2000, &0x500
     79            UCA0CTLW0 &= ~UCSPB; // UCSPB = 0(1 stop bit) OR 1(2 stop bits)
   \   000066   B2C000080005 BIC.W   #0x800, &0x500
     80            UCA0CTLW0 &= ~UCPEN; // No Parity
   \   00006C   B2C000800005 BIC.W   #0x8000, &0x500
     81            UCA0CTLW0 &= ~UCSYNC;
   \   000072   B2C000010005 BIC.W   #0x100, &0x500
     82            UCA0CTLW0 &= ~UC7BIT;
   \   000078   B2C000100005 BIC.W   #0x1000, &0x500
     83            UCA0CTLW0 |= UCMODE_0;
   \   00007E   924200050005 MOV.W   &0x500, &0x500
     84            UCA0BRW = 17 ; // 115,200 baud
   \   000084   B24011000605 MOV.W   #0x11, &0x506
     85            UCA0MCTLW = 0x4A00 ;
   \   00008A   B240004A0805 MOV.W   #0x4a00, &0x508
     86            UCA0CTLW0 &= ~UCSWRST ; // release from reset
   \   000090   92C30005     BIC.W   #0x1, &0x500
     87            //UCA0TXBUF = 0x00; // Prime the Pump
     88            UCA0IE |= UCRXIE; // Enable RX interrupt
   \   000094   92D31A05     BIS.W   #0x1, &0x51a
     89            break;
     90            }
     91            //------------------------------------------------------------------------------
     92          }
   \   000098   1001         RETA
   \   00009A                REQUIRE _A_UCA0CTLW0_L
   \   00009A                REQUIRE _A_UCA0BRW_L
   \   00009A                REQUIRE _A_UCA0MCTLW_L
   \   00009A                REQUIRE _A_UCA0IE_L

   \                                 In  segment CODE, align 2
     93          void Init_Serial_UCA1(char speed){
   \                     Init_Serial_UCA1:
     94            
     95            switch(speed){
   \   000000   4E4C         MOV.B   R12, R14
   \   000002   4E83         SUB.B   #0x0, R14
   \   000004   0324         JEQ     ??Init_Serial_UCA1_0
   \   000006   5E83         SUB.B   #0x1, R14
   \   000008   2424         JEQ     ??Init_Serial_UCA1_1
   \   00000A   1001         RETA
     96            case BAUD115200:
     97            //------------------------------------------------------------------------------
     98            // TX error (%) RX error (%)
     99            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
    100            // 8000000 4800 1 104 2 0xD6 -0.08 0.04 -0.10 0.14
    101            // 8000000 9600 1 52 1 0x49 -0.08 0.04 -0.10 0.14
    102            // 8000000 19200 1 26 0 0xB6 -0.08 0.16 -0.28 0.20
    103            // 8000000 57600 1 8 10 0xF7 -0.32 0.32 -1.00 0.36
    104            // 8000000 115200 1 4 5 0x55 -0.80 0.64 -1.12 1.76
    105            // 8000000 460800 0 17 0 0x4A -2.72 2.56 -3.76 7.28
    106            //------------------------------------------------------------------------------
    107            // Configure eUSCI_A0 for UART mode
    108            UCA1CTLW0 = 0;
   \                     ??Init_Serial_UCA1_0:
   \   00000C   82438005     MOV.W   #0x0, &0x580
    109            UCA1CTLW0 |= UCSWRST ; // Put eUSCI in reset
   \   000010   92D38005     BIS.W   #0x1, &0x580
    110            UCA1CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK
   \   000014   B2D080008005 BIS.W   #0x80, &0x580
    111            UCA1CTLW0 &= ~UCMSB; // MSB, LSB select
   \   00001A   B2C000208005 BIC.W   #0x2000, &0x580
    112            UCA1CTLW0 &= ~UCSPB; // UCSPB = 0(1 stop bit) OR 1(2 stop bits)
   \   000020   B2C000088005 BIC.W   #0x800, &0x580
    113            UCA1CTLW0 &= ~UCPEN; // No Parity
   \   000026   B2C000808005 BIC.W   #0x8000, &0x580
    114            UCA1CTLW0 &= ~UCSYNC;
   \   00002C   B2C000018005 BIC.W   #0x100, &0x580
    115            UCA1CTLW0 &= ~UC7BIT;
   \   000032   B2C000108005 BIC.W   #0x1000, &0x580
    116            UCA1CTLW0 |= UCMODE_0;
   \   000038   924280058005 MOV.W   &0x580, &0x580
    117            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
    118            // 8000000 115200 1 4 5 0x55 -0.80 0.64 -1.12 1.76
    119            // UCA?MCTLW = UCSx + UCFx + UCOS16
    120            UCA1BRW = 4 ; // 115,200 baud
   \   00003E   A2428605     MOV.W   #0x4, &0x586
    121            UCA1MCTLW = 0x5551 ;
   \   000042   B24051558805 MOV.W   #0x5551, &0x588
    122            UCA1CTLW0 &= ~UCSWRST ; // release from reset
   \   000048   92C38005     BIC.W   #0x1, &0x580
    123           // UCA1TXBUF = 0x00; // Prime the Pump
    124            UCA1IE |= UCRXIE; // Enable RX interrupt
   \   00004C   92D39A05     BIS.W   #0x1, &0x59a
    125            break;
   \   000050   1001         RETA
    126            case BAUD460800:
    127            UCA1CTLW0 = 0;
   \                     ??Init_Serial_UCA1_1:
   \   000052   82438005     MOV.W   #0x0, &0x580
    128            UCA1CTLW0 |= UCSWRST ; // Put eUSCI in reset
   \   000056   92D38005     BIS.W   #0x1, &0x580
    129            UCA1CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK
   \   00005A   B2D080008005 BIS.W   #0x80, &0x580
    130            UCA1CTLW0 &= ~UCMSB; // MSB, LSB select
   \   000060   B2C000208005 BIC.W   #0x2000, &0x580
    131            UCA1CTLW0 &= ~UCSPB; // UCSPB = 0(1 stop bit) OR 1(2 stop bits)
   \   000066   B2C000088005 BIC.W   #0x800, &0x580
    132            UCA1CTLW0 &= ~UCPEN; // No Parity
   \   00006C   B2C000808005 BIC.W   #0x8000, &0x580
    133            UCA1CTLW0 &= ~UCSYNC;
   \   000072   B2C000018005 BIC.W   #0x100, &0x580
    134            UCA1CTLW0 &= ~UC7BIT;
   \   000078   B2C000108005 BIC.W   #0x1000, &0x580
    135            UCA1CTLW0 |= UCMODE_0;
   \   00007E   924280058005 MOV.W   &0x580, &0x580
    136            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
    137            // 8000000 460800 0 17 0 0x4A -2.72 2.56 -3.76 7.28
    138            // UCA?MCTLW = UCSx + UCFx + UCOS16
    139            UCA1BRW = 17 ;
   \   000084   B24011008605 MOV.W   #0x11, &0x586
    140            UCA1MCTLW = 0x4A00 ;
   \   00008A   B240004A8805 MOV.W   #0x4a00, &0x588
    141            UCA1CTLW0 &= ~UCSWRST ; // release from reset
   \   000090   92C38005     BIC.W   #0x1, &0x580
    142            UCA1TXBUF = 0x00; // Prime the Pump
   \   000094   82438E05     MOV.W   #0x0, &0x58e
    143            UCA1IE |= UCRXIE; // Enable RX interrupt
   \   000098   92D39A05     BIS.W   #0x1, &0x59a
    144            break;
    145            }
    146            //------------------------------------------------------------------------------
    147          }
   \   00009C   1001         RETA
   \   00009E                REQUIRE _A_UCA1CTLW0_L
   \   00009E                REQUIRE _A_UCA1BRW_L
   \   00009E                REQUIRE _A_UCA1MCTLW_L
   \   00009E                REQUIRE _A_UCA1IE_L
   \   00009E                REQUIRE _A_UCA1TXBUF_L

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    148          char test_output[11];
   \                     test_output:
   \   000000                DS8 11
    149          #pragma vector=EUSCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    150          __interrupt void EUSCI_A0_ISR(void){
   \                     EUSCI_A0_ISR:
   \   000000   3F15         PUSHM.W #0x4, R15
    151            
    152            switch(__even_in_range(UCA0IV,0x08)){ // Bruh IDK what I did here needs to be fixed
   \   000002   1F421E05     MOV.W   &0x51e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for EUSCI_A0_ISR>_0`:
   \   000008   253C         JMP     ??EUSCI_A0_ISR_1
   \   00000A   033C         JMP     ??EUSCI_A0_ISR_3
   \   00000C   0C3C         JMP     ??EUSCI_A0_ISR_4
   \   00000E   223C         JMP     ??EUSCI_A0_ISR_1
   \   000010   213C         JMP     ??EUSCI_A0_ISR_1
    153            case 0: // Vector 0 - no interrupt
    154              break;
    155            case 2: // Vector 2 - RXIFG
    156              temp[0] =  UCA1RXBUF;
   \                     ??EUSCI_A0_ISR_3:
   \   000012   1E428C05     MOV.W   &0x58c, R14
   \   000016   C24E....     MOV.B   R14, &temp
    157              send(temp,Send_UCA1);
   \   00001A   5D43         MOV.B   #0x1, R13
   \   00001C   3C40....     MOV.W   #temp, R12
   \   000020   ........     CALLA   #send
    158              
    159              
    160              //    serial_bits = SERIAL_RX;
    161              //    *RX_write = UCA0RXBUF;// Writes UCA0RXBUF to current RING_BUF_A0 location
    162              //    count++;
    163              //    if(*RX_write != '\0' && rx_start == NULL){
    164              //      rx_start = RX_write;
    165              //      count = 0;
    166              //    }
    167              //    RX_write++;
    168              //    if(*(RX_write-1) == '\n' || count == 10){
    169              //      RX_write--;
    170              //      for(int i=0; i<SMALL_RING_SIZE; i++){
    171              //        if(rx_start == RX_write && i < PROCESS_BUF_LENGTH){
    172              //          process_buf_rx[i] = ' ';
    173              //        }
    174              //        else if(rx_start == RX_write){
    175              //          process_buf_rx[i] = '\0';
    176              //        } 
    177              //        else{
    178              //          if(rx_start == RING_BUF_A0+SMALL_RING_SIZE){
    179              //            rx_start = RING_BUF_A0;
    180              //          }
    181              //          process_buf_rx[i] = *(rx_start);
    182              //          rx_start++;
    183              //        }
    184              //      }
    185              //      serial_bits &= ~rx_buff_update;
    186              //      rx_start = NULL;
    187              //      RX_write++;
    188              //    }
    189              //    if(RX_write == RING_BUF_A0+SMALL_RING_SIZE){
    190              //      RX_write = RING_BUF_A0;
    191              //    }
    192              //    
    193              break;
   \   000024   173C         JMP     ??EUSCI_A0_ISR_1
    194            case 4: // Vector 4 – TXIFG
    195              if(Tx_String[i]=='\0'){//If the end of a string add line feed and turn off Tx
   \                     ??EUSCI_A0_ISR_4:
   \   000026   1F42....     MOV.W   &Tx_String, R15
   \   00002A   1F52....     ADD.W   &i, R15
   \   00002E   CF930000     CMP.B   #0x0, 0(R15)
   \   000032   0620         JNE     ??EUSCI_A0_ISR_2
    196                UCA0TXBUF = '\n';
   \   000034   B2400A000E05 MOV.W   #0xa, &0x50e
    197                UCA0IE &= ~UCTXIE;
   \   00003A   A2C31A05     BIC.W   #0x2, &0x51a
   \   00003E   0A3C         JMP     ??EUSCI_A0_ISR_1
    198              }else{// keep chars going
    199                UCA0TXBUF = Tx_String[i++];
   \                     ??EUSCI_A0_ISR_2:
   \   000040   1F42....     MOV.W   &Tx_String, R15
   \   000044   1F52....     ADD.W   &i, R15
   \   000048   6F4F         MOV.B   @R15, R15
   \   00004A   4F4F         MOV.B   R15, R15
   \   00004C   824F0E05     MOV.W   R15, &0x50e
   \   000050   9253....     ADD.W   #0x1, &i
    200              }
    201              //    serial_bits = SERIAL_TX;
    202              //    if(*TX_char=='\0'){
    203              //      UCA0TXBUF = '\n';
    204              //      UCA0IE &= ~UCTXIE;
    205              //      //TX_char=TX_A1;
    206              //      serial_bits |= tx_buff_update;
    207              //      TX_char=process_buf_rx;
    208              //    }
    209              //      else{
    210              //        //UCA0IE &= ~UCTXIE; //<=====
    211              //        UCA0TXBUF = *TX_char;
    212              //        TX_char++;
    213              //      }
    214              break;
    215            default: break;
    216            }
    217          }
   \                     ??EUSCI_A0_ISR_1:
   \   000054   3C17         POPM.W  #0x4, R15
   \   000056   0013         RETI
   \   000058                REQUIRE _A_UCA1RXBUF_L
   \   000058                REQUIRE _A_UCA0TXBUF_L
   \   000058                REQUIRE _A_UCA0IE_L
   \   000058                REQUIRE _A_UCA0IV_L
    218          #pragma vector=EUSCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    219          __interrupt void EUSCI_A1_ISR(void){
   \                     EUSCI_A1_ISR:
   \   000000   3F15         PUSHM.W #0x4, R15
    220            switch(__even_in_range(UCA1IV,0x08)){
   \   000002   1F429E05     MOV.W   &0x59e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for EUSCI_A1_ISR>_0`:
   \   000008   283C         JMP     ??EUSCI_A1_ISR_0
   \   00000A   033C         JMP     ??EUSCI_A1_ISR_2
   \   00000C   0F3C         JMP     ??EUSCI_A1_ISR_3
   \   00000E   253C         JMP     ??EUSCI_A1_ISR_0
   \   000010   243C         JMP     ??EUSCI_A1_ISR_0
    221            case 0: // Vector 0 - no interrupt
    222              break;
    223            case 2: // Vector 2 - RXIFG
    224              //Need to save the rx to send to the UCA0 (IOT)
    225              temp[0] =  UCA1RXBUF;
   \                     ??EUSCI_A1_ISR_2:
   \   000012   1E428C05     MOV.W   &0x58c, R14
   \   000016   C24E....     MOV.B   R14, &temp
    226              send(temp,Send_UCA0);
   \   00001A   4D43         MOV.B   #0x0, R13
   \   00001C   3C40....     MOV.W   #temp, R12
   \   000020   ........     CALLA   #send
    227              //UCA0TXBUF = temp;
    228              serial_bits |= Serial_off;
   \   000024   B2D02000.... BIS.W   #0x20, &serial_bits
    229              break;
   \   00002A   173C         JMP     ??EUSCI_A1_ISR_0
    230            case 4: // Vector 4 – TXIFG
    231              if(Tx_String[i]=='\0'){//If the end of a string add line feed and turn off Tx
   \                     ??EUSCI_A1_ISR_3:
   \   00002C   1F42....     MOV.W   &Tx_String, R15
   \   000030   1F52....     ADD.W   &i, R15
   \   000034   CF930000     CMP.B   #0x0, 0(R15)
   \   000038   0620         JNE     ??EUSCI_A1_ISR_1
    232                  UCA1TXBUF = '\n';
   \   00003A   B2400A008E05 MOV.W   #0xa, &0x58e
    233                  UCA1IE &= ~UCTXIE;
   \   000040   A2C39A05     BIC.W   #0x2, &0x59a
   \   000044   0A3C         JMP     ??EUSCI_A1_ISR_0
    234              }else{// keep chars going
    235                UCA1TXBUF = Tx_String[i++];
   \                     ??EUSCI_A1_ISR_1:
   \   000046   1F42....     MOV.W   &Tx_String, R15
   \   00004A   1F52....     ADD.W   &i, R15
   \   00004E   6F4F         MOV.B   @R15, R15
   \   000050   4F4F         MOV.B   R15, R15
   \   000052   824F8E05     MOV.W   R15, &0x58e
   \   000056   9253....     ADD.W   #0x1, &i
    236              }
    237              break;
    238            
    239            }
    240          }
   \                     ??EUSCI_A1_ISR_0:
   \   00005A   3C17         POPM.W  #0x4, R15
   \   00005C   0013         RETI
   \   00005E                REQUIRE _A_UCA1RXBUF_L
   \   00005E                REQUIRE _A_UCA1TXBUF_L
   \   00005E                REQUIRE _A_UCA1IE_L
   \   00005E                REQUIRE _A_UCA1IV_L

   \                                 In  segment INTVEC, offset 0x40, root
   \                     `??EUSCI_A1_ISR::??INTVEC 64`:
   \   000040   ....         DC16    EUSCI_A1_ISR

   \                                 In  segment INTVEC, offset 0x42, root
   \                     `??EUSCI_A0_ISR::??INTVEC 66`:
   \   000042   ....         DC16    EUSCI_A0_ISR

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for RX_write>`:
   \   000000   ....         DC16 RING_BUF_A0
    241          
    242          
    243          
    244          
    245          
    246          
    247          
    248          
    249          
    250          
    251          
    252          
    253          
    254          
    255          
    256          
    257          
    258          //This is a git test
    259          //      switch(baud){
    260          //      case BAUD115200:
    261          //        change_display_line( BAUD115200_STRING,DISPLAY2);
    262          //        //sw2 buton press switch to 460800
    263          //        //sw1 button press transmit current process buffer
    264          //        if(SW1_AND_TOGGLED){
    265          //          SW1_CLEAR;
    266          //          serial_bits = SERIAL_TX; // Sets the flag to chage current buffer in main.
    267          //          //x   strcpy(process_buf_tx,process_buf_rx);
    268          //          UCA0IE |= UCTXIE;
    269          //          //UCA0TXBUF = '\0';
    270          //          //move rx string to tx position
    271          //        }
    272          //        if(SW2_AND_TOGGLED){
    273          //          SW2_CLEAR;
    274          //          baud=BAUD460800;
    275          //          Init_Serial_UCA0(BAUD460800);
    276          //        }
    277          //        break;
    278          //      case BAUD460800:
    279          //        change_display_line( BAUD460800_STRING,DISPLAY2);
    280          //        if(SW1_AND_TOGGLED){
    281          //          SW1_CLEAR;
    282          //          UCA0IE |= UCTXIE;
    283          //          //UCA0TXBUF = '\0';
    284          //        }
    285          //        if(SW2_AND_TOGGLED){
    286          //          SW2_CLEAR;
    287          //          baud=BAUD115200;
    288          //          Init_Serial_UCA0(BAUD115200);
    289          //        }
    290          //        break;
    291          //        
    292          //      }
    293          //      // have two buffer a display buffer and a write buffer.
    294          //      if(update_display==UPDATED){
    295          //        switch(serial_bits&0x7){
    296          //        case SERIAL_WAITING:
    297          //          
    298          //          waiting_animation();
    299          //          
    300          //          break;
    301          //        case SERIAL_RX:
    302          //          change_display_line(RECIVED,DISPLAY0);
    303          //          clear_line(DISPLAY1);
    304          //          change_display_line(process_buf_rx,DISPLAY3);
    305          //          break;
    306          //        case SERIAL_TX:
    307          //          change_display_line(TRASMIT,DISPLAY0);
    308          //          clear_line(DISPLAY3);
    309          //          change_display_line(process_buf_rx,DISPLAY1);
    310          //          break;
    311          //        default:
    312          //          serial_bits = SERIAL_WAITING;
    313          //          break;
    314          //        }
    315          //      }
    316          //    

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     12   EUSCI_A0_ISR
       12   -> send
     12   EUSCI_A1_ISR
       12   -> send
      4   Init_Serial_UCA0
      4   Init_Serial_UCA1
      4   send


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for RX_write>
      88  EUSCI_A0_ISR
       2  EUSCI_A0_ISR::??INTVEC 66
      94  EUSCI_A1_ISR
       2  EUSCI_A1_ISR::??INTVEC 64
     154  Init_Serial_UCA0
     158  Init_Serial_UCA1
      16  RING_BUF_A0
       2  RX_read
       2  RX_write
      16  TX_A1
       2  Tx_String
      16  USB_Char_Rx
       2  _A_UCA0BRW_L
       2  _A_UCA0CTLW0_L
       2  _A_UCA0IE_L
       2  _A_UCA0IV_L
       2  _A_UCA0MCTLW_L
       2  _A_UCA0TXBUF_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1IE_L
       2  _A_UCA1IV_L
       2  _A_UCA1MCTLW_L
       2  _A_UCA1RXBUF_L
       2  _A_UCA1TXBUF_L
       2  count
       2  i
      33  process_buf_tx
       2  rx_start
      32  send
       2  temp
      11  test_output
       2  usb_rx_ring_wr

 
 344 bytes in segment CODE
  26 bytes in segment DATA16_AN
   2 bytes in segment DATA16_I
   2 bytes in segment DATA16_ID
 106 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 182 bytes in segment ISR_CODE
 
 526 bytes of CODE  memory
   2 bytes of CONST memory (+  4 bytes shared)
 108 bytes of DATA  memory (+ 26 bytes shared)

Errors: none
Warnings: none
