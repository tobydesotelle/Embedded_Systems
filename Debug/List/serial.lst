###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          13/Nov/2022  21:20:17
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\serial.c
#    Command line  =  
#        -f C:\Users\TOBIAS~1\AppData\Local\Temp\EW80CE.tmp ("C:\Users\Tobias
#        Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\serial.c" -lC
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List" -o
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I
#        ./ --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List\serial.lst
#    Object file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj\serial.r43
#
###############################################################################

C:\Users\Tobias Desotelle\OneDrive - UNC Asheville\Documents\GitHub\Embedded_Systems\serial.c
      1          #include "macros.h"

   \                                 In  segment DATA16_AN, at 0x500
   \   union <unnamed> _A_UCA0CTLW0_L
   \                     _A_UCA0CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x506
   \   union <unnamed> _A_UCA0BRW_L
   \                     _A_UCA0BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x508
   \   union <unnamed> _A_UCA0MCTLW_L
   \                     _A_UCA0MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50c
   \   union <unnamed> _A_UCA0RXBUF_L
   \                     _A_UCA0RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50e
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51e
   \   union <unnamed> _A_UCA0IV_L
   \                     _A_UCA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x580
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x586
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x588
   \   union <unnamed> _A_UCA1MCTLW_L
   \                     _A_UCA1MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58c
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58e
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59a
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59e
   \   union <unnamed> _A_UCA1IV_L
   \                     _A_UCA1IV_L:
   \   000000                DS8 2
      2          
      3          extern volatile unsigned short serial_bits;
      4          #define eUCA0_rx                ()
      5          
      6          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      7          volatile unsigned int usb_rx_ring_wr;
   \                     usb_rx_ring_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      8          volatile char USB_Char_Rx[SMALL_RING_SIZE];
   \                     USB_Char_Rx:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      9          char temp;
   \                     temp:
   \   000000                DS8 1
     10          //char process_buf_back[32];
     11          //char process_buf_front[32];

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     12          char process_buf_rx[PROCESS_BUF_LENGTH];
   \                     process_buf_rx:
   \   000000                DS8 11

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     13          char process_buf_tx[PROCESS_BUF_LENGTH];
   \                     process_buf_tx:
   \   000000                DS8 11

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     14          int count=0;
   \                     count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          char RING_BUF_A0[SMALL_RING_SIZE];
   \                     RING_BUF_A0:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          char *rx_start;
   \                     rx_start:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          char TX_A1[SMALL_RING_SIZE];
   \                     TX_A1:
   \   000000                DS8 16

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     18          char *TX_char=process_buf_rx; 
   \                     TX_char:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for TX_char>`
     19          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     20          char *RX_write=RING_BUF_A0;
   \                     RX_write:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for RX_write>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          char *RX_read;
   \                     RX_read:
   \   000000                DS8 2
     22          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          char *Tx_String;
   \                     Tx_String:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          unsigned int i;
   \                     i:
   \   000000                DS8 2
     25          
     26          #define Send_UCA0        (0x00)
     27          #define Send_UCA1        (0x01)

   \                                 In  segment CODE, align 2
     28          void send(char *string, char port){
   \                     send:
     29            switch(port){
   \   000000   4E4D         MOV.B   R13, R14
   \   000002   4E83         SUB.B   #0x0, R14
   \   000004   0824         JEQ     ??send_1
   \   000006   5E83         SUB.B   #0x1, R14
   \   000008   0620         JNE     ??send_1
     30            case Send_UCA0:
     31              break;
     32            case Send_UCA1:
     33              i=0;
   \   00000A   8243....     MOV.W   #0x0, &i
     34              Tx_String = string;
   \   00000E   824C....     MOV.W   R12, &Tx_String
     35              UCA1IE |= UCTXIE;
   \   000012   A2D39A05     BIS.W   #0x2, &0x59a
     36              //UCA1TXBUF = Tx_String[i];
     37              break;
     38            }
     39            
     40          }
   \                     ??send_1:
   \   000016   1001         RETA
   \   000018                REQUIRE _A_UCA1IE_L
     41          

   \                                 In  segment CODE, align 2
     42          void Init_Serial_UCA0(char speed){
   \                     Init_Serial_UCA0:
     43          
     44            switch(speed){
   \   000000   4E4C         MOV.B   R12, R14
   \   000002   4E83         SUB.B   #0x0, R14
   \   000004   0324         JEQ     ??Init_Serial_UCA0_0
   \   000006   5E83         SUB.B   #0x1, R14
   \   000008   2424         JEQ     ??Init_Serial_UCA0_1
   \   00000A   1001         RETA
     45            case BAUD115200:
     46            //------------------------------------------------------------------------------
     47            // TX error (%) RX error (%)
     48            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
     49            // 8000000 4800 1 104 2 0xD6 -0.08 0.04 -0.10 0.14
     50            // 8000000 9600 1 52 1 0x49 -0.08 0.04 -0.10 0.14
     51            // 8000000 19200 1 26 0 0xB6 -0.08 0.16 -0.28 0.20
     52            // 8000000 57600 1 8 10 0xF7 -0.32 0.32 -1.00 0.36
     53            // 8000000 115200 1 4 5 0x55 -0.80 0.64 -1.12 1.76
     54            // 8000000 460800 0 17 0 0x4A -2.72 2.56 -3.76 7.28
     55            //------------------------------------------------------------------------------
     56            // Configure eUSCI_A0 for UART mode
     57            UCA0CTLW0 = 0;
   \                     ??Init_Serial_UCA0_0:
   \   00000C   82430005     MOV.W   #0x0, &0x500
     58            UCA0CTLW0 |= UCSWRST ; // Put eUSCI in reset
   \   000010   92D30005     BIS.W   #0x1, &0x500
     59            UCA0CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK
   \   000014   B2D080000005 BIS.W   #0x80, &0x500
     60            UCA0CTLW0 &= ~UCMSB; // MSB, LSB select
   \   00001A   B2C000200005 BIC.W   #0x2000, &0x500
     61            UCA0CTLW0 &= ~UCSPB; // UCSPB = 0(1 stop bit) OR 1(2 stop bits)
   \   000020   B2C000080005 BIC.W   #0x800, &0x500
     62            UCA0CTLW0 &= ~UCPEN; // No Parity
   \   000026   B2C000800005 BIC.W   #0x8000, &0x500
     63            UCA0CTLW0 &= ~UCSYNC;
   \   00002C   B2C000010005 BIC.W   #0x100, &0x500
     64            UCA0CTLW0 &= ~UC7BIT;
   \   000032   B2C000100005 BIC.W   #0x1000, &0x500
     65            UCA0CTLW0 |= UCMODE_0;
   \   000038   924200050005 MOV.W   &0x500, &0x500
     66            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
     67            // 8000000 115200 1 4 5 0x55 -0.80 0.64 -1.12 1.76
     68            // UCA?MCTLW = UCSx + UCFx + UCOS16
     69            UCA0BRW = 4 ; // 115,200 baud
   \   00003E   A2420605     MOV.W   #0x4, &0x506
     70            UCA0MCTLW = 0x5551 ;
   \   000042   B24051550805 MOV.W   #0x5551, &0x508
     71            UCA0CTLW0 &= ~UCSWRST ; // release from reset
   \   000048   92C30005     BIC.W   #0x1, &0x500
     72            //UCA0TXBUF = 0x00; // Prime the Pump
     73            UCA0IE |= UCRXIE; // Enable RX interrupt
   \   00004C   92D31A05     BIS.W   #0x1, &0x51a
     74            break;
   \   000050   1001         RETA
     75            case BAUD460800:
     76            UCA0CTLW0 = 0;
   \                     ??Init_Serial_UCA0_1:
   \   000052   82430005     MOV.W   #0x0, &0x500
     77            UCA0CTLW0 |= UCSWRST ; // Put eUSCI in reset
   \   000056   92D30005     BIS.W   #0x1, &0x500
     78            UCA0CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK
   \   00005A   B2D080000005 BIS.W   #0x80, &0x500
     79            UCA0CTLW0 &= ~UCMSB; // MSB, LSB select
   \   000060   B2C000200005 BIC.W   #0x2000, &0x500
     80            UCA0CTLW0 &= ~UCSPB; // UCSPB = 0(1 stop bit) OR 1(2 stop bits)
   \   000066   B2C000080005 BIC.W   #0x800, &0x500
     81            UCA0CTLW0 &= ~UCPEN; // No Parity
   \   00006C   B2C000800005 BIC.W   #0x8000, &0x500
     82            UCA0CTLW0 &= ~UCSYNC;
   \   000072   B2C000010005 BIC.W   #0x100, &0x500
     83            UCA0CTLW0 &= ~UC7BIT;
   \   000078   B2C000100005 BIC.W   #0x1000, &0x500
     84            UCA0CTLW0 |= UCMODE_0;
   \   00007E   924200050005 MOV.W   &0x500, &0x500
     85            UCA0BRW = 17 ; // 115,200 baud
   \   000084   B24011000605 MOV.W   #0x11, &0x506
     86            UCA0MCTLW = 0x4A00 ;
   \   00008A   B240004A0805 MOV.W   #0x4a00, &0x508
     87            UCA0CTLW0 &= ~UCSWRST ; // release from reset
   \   000090   92C30005     BIC.W   #0x1, &0x500
     88            //UCA0TXBUF = 0x00; // Prime the Pump
     89            UCA0IE |= UCRXIE; // Enable RX interrupt
   \   000094   92D31A05     BIS.W   #0x1, &0x51a
     90            break;
     91            }
     92            //------------------------------------------------------------------------------
     93          }
   \   000098   1001         RETA
   \   00009A                REQUIRE _A_UCA0CTLW0_L
   \   00009A                REQUIRE _A_UCA0BRW_L
   \   00009A                REQUIRE _A_UCA0MCTLW_L
   \   00009A                REQUIRE _A_UCA0IE_L

   \                                 In  segment CODE, align 2
     94          void Init_Serial_UCA1(char speed){
   \                     Init_Serial_UCA1:
     95            
     96            switch(speed){
   \   000000   4E4C         MOV.B   R12, R14
   \   000002   4E83         SUB.B   #0x0, R14
   \   000004   0324         JEQ     ??Init_Serial_UCA1_0
   \   000006   5E83         SUB.B   #0x1, R14
   \   000008   2424         JEQ     ??Init_Serial_UCA1_1
   \   00000A   1001         RETA
     97            case BAUD115200:
     98            //------------------------------------------------------------------------------
     99            // TX error (%) RX error (%)
    100            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
    101            // 8000000 4800 1 104 2 0xD6 -0.08 0.04 -0.10 0.14
    102            // 8000000 9600 1 52 1 0x49 -0.08 0.04 -0.10 0.14
    103            // 8000000 19200 1 26 0 0xB6 -0.08 0.16 -0.28 0.20
    104            // 8000000 57600 1 8 10 0xF7 -0.32 0.32 -1.00 0.36
    105            // 8000000 115200 1 4 5 0x55 -0.80 0.64 -1.12 1.76
    106            // 8000000 460800 0 17 0 0x4A -2.72 2.56 -3.76 7.28
    107            //------------------------------------------------------------------------------
    108            // Configure eUSCI_A0 for UART mode
    109            UCA1CTLW0 = 0;
   \                     ??Init_Serial_UCA1_0:
   \   00000C   82438005     MOV.W   #0x0, &0x580
    110            UCA1CTLW0 |= UCSWRST ; // Put eUSCI in reset
   \   000010   92D38005     BIS.W   #0x1, &0x580
    111            UCA1CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK
   \   000014   B2D080008005 BIS.W   #0x80, &0x580
    112            UCA1CTLW0 &= ~UCMSB; // MSB, LSB select
   \   00001A   B2C000208005 BIC.W   #0x2000, &0x580
    113            UCA1CTLW0 &= ~UCSPB; // UCSPB = 0(1 stop bit) OR 1(2 stop bits)
   \   000020   B2C000088005 BIC.W   #0x800, &0x580
    114            UCA1CTLW0 &= ~UCPEN; // No Parity
   \   000026   B2C000808005 BIC.W   #0x8000, &0x580
    115            UCA1CTLW0 &= ~UCSYNC;
   \   00002C   B2C000018005 BIC.W   #0x100, &0x580
    116            UCA1CTLW0 &= ~UC7BIT;
   \   000032   B2C000108005 BIC.W   #0x1000, &0x580
    117            UCA1CTLW0 |= UCMODE_0;
   \   000038   924280058005 MOV.W   &0x580, &0x580
    118            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
    119            // 8000000 115200 1 4 5 0x55 -0.80 0.64 -1.12 1.76
    120            // UCA?MCTLW = UCSx + UCFx + UCOS16
    121            UCA1BRW = 4 ; // 115,200 baud
   \   00003E   A2428605     MOV.W   #0x4, &0x586
    122            UCA1MCTLW = 0x5551 ;
   \   000042   B24051558805 MOV.W   #0x5551, &0x588
    123            UCA1CTLW0 &= ~UCSWRST ; // release from reset
   \   000048   92C38005     BIC.W   #0x1, &0x580
    124           // UCA1TXBUF = 0x00; // Prime the Pump
    125            UCA1IE |= UCRXIE; // Enable RX interrupt
   \   00004C   92D39A05     BIS.W   #0x1, &0x59a
    126            break;
   \   000050   1001         RETA
    127            case BAUD460800:
    128            UCA1CTLW0 = 0;
   \                     ??Init_Serial_UCA1_1:
   \   000052   82438005     MOV.W   #0x0, &0x580
    129            UCA1CTLW0 |= UCSWRST ; // Put eUSCI in reset
   \   000056   92D38005     BIS.W   #0x1, &0x580
    130            UCA1CTLW0 |= UCSSEL__SMCLK; // Set SMCLK as fBRCLK
   \   00005A   B2D080008005 BIS.W   #0x80, &0x580
    131            UCA1CTLW0 &= ~UCMSB; // MSB, LSB select
   \   000060   B2C000208005 BIC.W   #0x2000, &0x580
    132            UCA1CTLW0 &= ~UCSPB; // UCSPB = 0(1 stop bit) OR 1(2 stop bits)
   \   000066   B2C000088005 BIC.W   #0x800, &0x580
    133            UCA1CTLW0 &= ~UCPEN; // No Parity
   \   00006C   B2C000808005 BIC.W   #0x8000, &0x580
    134            UCA1CTLW0 &= ~UCSYNC;
   \   000072   B2C000018005 BIC.W   #0x100, &0x580
    135            UCA1CTLW0 &= ~UC7BIT;
   \   000078   B2C000108005 BIC.W   #0x1000, &0x580
    136            UCA1CTLW0 |= UCMODE_0;
   \   00007E   924280058005 MOV.W   &0x580, &0x580
    137            // BRCLK Baudrate UCOS16 UCBRx UCFx UCSx neg pos neg pos
    138            // 8000000 460800 0 17 0 0x4A -2.72 2.56 -3.76 7.28
    139            // UCA?MCTLW = UCSx + UCFx + UCOS16
    140            UCA1BRW = 17 ;
   \   000084   B24011008605 MOV.W   #0x11, &0x586
    141            UCA1MCTLW = 0x4A00 ;
   \   00008A   B240004A8805 MOV.W   #0x4a00, &0x588
    142            UCA1CTLW0 &= ~UCSWRST ; // release from reset
   \   000090   92C38005     BIC.W   #0x1, &0x580
    143            UCA1TXBUF = 0x00; // Prime the Pump
   \   000094   82438E05     MOV.W   #0x0, &0x58e
    144            UCA1IE |= UCRXIE; // Enable RX interrupt
   \   000098   92D39A05     BIS.W   #0x1, &0x59a
    145            break;
    146            }
    147            //------------------------------------------------------------------------------
    148          }
   \   00009C   1001         RETA
   \   00009E                REQUIRE _A_UCA1CTLW0_L
   \   00009E                REQUIRE _A_UCA1BRW_L
   \   00009E                REQUIRE _A_UCA1MCTLW_L
   \   00009E                REQUIRE _A_UCA1IE_L
   \   00009E                REQUIRE _A_UCA1TXBUF_L

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    149          char test_output[11];
   \                     test_output:
   \   000000                DS8 11
    150          #pragma vector=EUSCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    151          __interrupt void EUSCI_A0_ISR(void){
   \                     EUSCI_A0_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
    152            
    153            switch(__even_in_range(UCA0IV,0x08)){ // Bruh IDK what I did here needs to be fixed
   \   000002   1F421E05     MOV.W   &0x51e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for EUSCI_A0_ISR>_0`:
   \   000008   773C         JMP     ??EUSCI_A0_ISR_3
   \   00000A   033C         JMP     ??EUSCI_A0_ISR_13
   \   00000C   5B3C         JMP     ??EUSCI_A0_ISR_14
   \   00000E   743C         JMP     ??EUSCI_A0_ISR_3
   \   000010   733C         JMP     ??EUSCI_A0_ISR_3
    154            case 0: // Vector 0 - no interrupt
    155              break;
    156            case 2: // Vector 2 - RXIFG
    157              serial_bits = SERIAL_RX;
   \                     ??EUSCI_A0_ISR_13:
   \   000012   A243....     MOV.W   #0x2, &serial_bits
    158              *RX_write = UCA0RXBUF;// Writes UCA0RXBUF to current RING_BUF_A0 location
   \   000016   1E420C05     MOV.W   &0x50c, R14
   \   00001A   1F42....     MOV.W   &RX_write, R15
   \   00001E   CF4E0000     MOV.B   R14, 0(R15)
    159              count++;
   \   000022   9253....     ADD.W   #0x1, &count
    160              if(*RX_write != '\0' && rx_start == NULL){
   \   000026   1F42....     MOV.W   &RX_write, R15
   \   00002A   CF930000     CMP.B   #0x0, 0(R15)
   \   00002E   0824         JEQ     ??EUSCI_A0_ISR_5
   \   000030   8293....     CMP.W   #0x0, &rx_start
   \   000034   0520         JNE     ??EUSCI_A0_ISR_5
    161                rx_start = RX_write;
   \   000036   9242........ MOV.W   &RX_write, &rx_start
    162                count = 0;
   \   00003C   8243....     MOV.W   #0x0, &count
    163              }
    164              RX_write++;
   \                     ??EUSCI_A0_ISR_5:
   \   000040   9253....     ADD.W   #0x1, &RX_write
    165              if(*(RX_write-1) == '\n' || count == 10){
   \   000044   1F42....     MOV.W   &RX_write, R15
   \   000048   FF900A00FFFF CMP.B   #0xa, 0xffff(R15)
   \   00004E   0424         JEQ     ??EUSCI_A0_ISR_6
   \   000050   B2900A00.... CMP.W   #0xa, &count
   \   000056   2E20         JNE     ??EUSCI_A0_ISR_7
    166                RX_write--;
   \                     ??EUSCI_A0_ISR_6:
   \   000058   B253....     ADD.W   #0xffff, &RX_write
    167                for(int i=0; i<SMALL_RING_SIZE; i++){
   \   00005C   0F43         MOV.W   #0x0, R15
   \                     ??EUSCI_A0_ISR_0:
   \   00005E   3F901000     CMP.W   #0x10, R15
   \   000062   2134         JGE     ??EUSCI_A0_ISR_8
    168                  if(rx_start == RX_write && i < PROCESS_BUF_LENGTH){
   \   000064   9292........ CMP.W   &RX_write, &rx_start
   \   00006A   0720         JNE     ??EUSCI_A0_ISR_9
   \   00006C   3F900B00     CMP.W   #0xb, R15
   \   000070   0434         JGE     ??EUSCI_A0_ISR_9
    169                    process_buf_rx[i] = ' ';
   \   000072   FF402000.... MOV.B   #0x20, process_buf_rx(R15)
   \   000078   143C         JMP     ??EUSCI_A0_ISR_4
    170                  }
    171                  else if(rx_start == RX_write){
   \                     ??EUSCI_A0_ISR_9:
   \   00007A   9292........ CMP.W   &RX_write, &rx_start
   \   000080   0320         JNE     ??EUSCI_A0_ISR_10
    172                    process_buf_rx[i] = '\0';
   \   000082   CF43....     MOV.B   #0x0, process_buf_rx(R15)
   \   000086   0D3C         JMP     ??EUSCI_A0_ISR_4
    173                  } 
    174                  else{
    175                    if(rx_start == RING_BUF_A0+SMALL_RING_SIZE){
   \                     ??EUSCI_A0_ISR_10:
   \   000088   B290........ CMP.W   #RING_BUF_A0 + 16, &rx_start
   \   00008E   0320         JNE     ??EUSCI_A0_ISR_11
    176                      rx_start = RING_BUF_A0;
   \   000090   B240........ MOV.W   #RING_BUF_A0, &rx_start
    177                    }
    178                    process_buf_rx[i] = *(rx_start);
   \                     ??EUSCI_A0_ISR_11:
   \   000096   1E42....     MOV.W   &rx_start, R14
   \   00009A   EF4E....     MOV.B   @R14, process_buf_rx(R15)
    179                    rx_start++;
   \   00009E   9253....     ADD.W   #0x1, &rx_start
    180                  }
    181                }
   \                     ??EUSCI_A0_ISR_4:
   \   0000A2   1F53         ADD.W   #0x1, R15
   \   0000A4   DC3F         JMP     ??EUSCI_A0_ISR_0
    182                serial_bits &= ~rx_buff_update;
   \                     ??EUSCI_A0_ISR_8:
   \   0000A6   B2C01000.... BIC.W   #0x10, &serial_bits
    183                rx_start = NULL;
   \   0000AC   8243....     MOV.W   #0x0, &rx_start
    184                RX_write++;
   \   0000B0   9253....     ADD.W   #0x1, &RX_write
    185              }
    186              if(RX_write == RING_BUF_A0+SMALL_RING_SIZE){
   \                     ??EUSCI_A0_ISR_7:
   \   0000B4   B290........ CMP.W   #RING_BUF_A0 + 16, &RX_write
   \   0000BA   1E20         JNE     ??EUSCI_A0_ISR_3
    187                RX_write = RING_BUF_A0;
   \   0000BC   B240........ MOV.W   #RING_BUF_A0, &RX_write
    188              }
    189              
    190              break;
   \   0000C2   1A3C         JMP     ??EUSCI_A0_ISR_3
    191            case 4: // Vector 4 – TXIFG
    192              serial_bits = SERIAL_TX;
   \                     ??EUSCI_A0_ISR_14:
   \   0000C4   A242....     MOV.W   #0x4, &serial_bits
    193              if(*TX_char=='\0'){
   \   0000C8   1F42....     MOV.W   &TX_char, R15
   \   0000CC   CF930000     CMP.B   #0x0, 0(R15)
   \   0000D0   0B20         JNE     ??EUSCI_A0_ISR_12
    194                UCA0TXBUF = '\n';
   \   0000D2   B2400A000E05 MOV.W   #0xa, &0x50e
    195                UCA0IE &= ~UCTXIE;
   \   0000D8   A2C31A05     BIC.W   #0x2, &0x51a
    196                //TX_char=TX_A1;
    197                serial_bits |= tx_buff_update;
   \   0000DC   B2D2....     BIS.W   #0x8, &serial_bits
    198                TX_char=process_buf_rx;
   \   0000E0   B240........ MOV.W   #process_buf_rx, &TX_char
   \   0000E6   083C         JMP     ??EUSCI_A0_ISR_3
    199              }
    200                else{
    201                  //UCA0IE &= ~UCTXIE; //<=====
    202                  UCA0TXBUF = *TX_char;
   \                     ??EUSCI_A0_ISR_12:
   \   0000E8   1F42....     MOV.W   &TX_char, R15
   \   0000EC   6F4F         MOV.B   @R15, R15
   \   0000EE   4F4F         MOV.B   R15, R15
   \   0000F0   824F0E05     MOV.W   R15, &0x50e
    203                  TX_char++;
   \   0000F4   9253....     ADD.W   #0x1, &TX_char
    204                }
    205              break;
    206            default: break;
    207            }
    208          }
   \                     ??EUSCI_A0_ISR_3:
   \   0000F8   1E17         POPM.W  #0x2, R15
   \   0000FA   0013         RETI
   \   0000FC                REQUIRE _A_UCA0RXBUF_L
   \   0000FC                REQUIRE _A_UCA0TXBUF_L
   \   0000FC                REQUIRE _A_UCA0IE_L
   \   0000FC                REQUIRE _A_UCA0IV_L
    209          #pragma vector=EUSCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    210          __interrupt void EUSCI_A1_ISR(void){
   \                     EUSCI_A1_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
    211            switch(__even_in_range(UCA1IV,0x08)){
   \   000002   1F429E05     MOV.W   &0x59e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for EUSCI_A1_ISR>_0`:
   \   000008   283C         JMP     ??EUSCI_A1_ISR_0
   \   00000A   033C         JMP     ??EUSCI_A1_ISR_2
   \   00000C   0F3C         JMP     ??EUSCI_A1_ISR_3
   \   00000E   253C         JMP     ??EUSCI_A1_ISR_0
   \   000010   243C         JMP     ??EUSCI_A1_ISR_0
    212            case 0: // Vector 0 - no interrupt
    213              break;
    214            case 2: // Vector 2 - RXIFG
    215              temp =  UCA1RXBUF;
   \                     ??EUSCI_A1_ISR_2:
   \   000012   1E428C05     MOV.W   &0x58c, R14
   \   000016   C24E....     MOV.B   R14, &temp
    216              UCA1TXBUF = temp;
   \   00001A   5F42....     MOV.B   &temp, R15
   \   00001E   4F4F         MOV.B   R15, R15
   \   000020   824F8E05     MOV.W   R15, &0x58e
    217              serial_bits |= Serial_off;
   \   000024   B2D02000.... BIS.W   #0x20, &serial_bits
    218              break;
   \   00002A   173C         JMP     ??EUSCI_A1_ISR_0
    219            case 4: // Vector 4 – TXIFG
    220              if(Tx_String[i]=='\0'){
   \                     ??EUSCI_A1_ISR_3:
   \   00002C   1F42....     MOV.W   &Tx_String, R15
   \   000030   1F52....     ADD.W   &i, R15
   \   000034   CF930000     CMP.B   #0x0, 0(R15)
   \   000038   0620         JNE     ??EUSCI_A1_ISR_1
    221                  UCA1TXBUF = '\n';
   \   00003A   B2400A008E05 MOV.W   #0xa, &0x58e
    222                  UCA1IE &= ~UCTXIE;
   \   000040   A2C39A05     BIC.W   #0x2, &0x59a
   \   000044   0A3C         JMP     ??EUSCI_A1_ISR_0
    223              }else{
    224                UCA1TXBUF = Tx_String[i++];
   \                     ??EUSCI_A1_ISR_1:
   \   000046   1F42....     MOV.W   &Tx_String, R15
   \   00004A   1F52....     ADD.W   &i, R15
   \   00004E   6F4F         MOV.B   @R15, R15
   \   000050   4F4F         MOV.B   R15, R15
   \   000052   824F8E05     MOV.W   R15, &0x58e
   \   000056   9253....     ADD.W   #0x1, &i
    225              }
    226          //    if(send_this[i]=='\0'){
    227          //      i++;
    228          //      UCA1TXBUF = send_this[i];
    229          //    }else{
    230          //      i = 0;
    231          //      UCA1TXBUF = '\n';
    232          //    }
    233              break;
    234            
    235            }
    236          }
   \                     ??EUSCI_A1_ISR_0:
   \   00005A   1E17         POPM.W  #0x2, R15
   \   00005C   0013         RETI
   \   00005E                REQUIRE _A_UCA1RXBUF_L
   \   00005E                REQUIRE _A_UCA1TXBUF_L
   \   00005E                REQUIRE _A_UCA1IE_L
   \   00005E                REQUIRE _A_UCA1IV_L

   \                                 In  segment INTVEC, offset 0x40, root
   \                     `??EUSCI_A1_ISR::??INTVEC 64`:
   \   000040   ....         DC16    EUSCI_A1_ISR

   \                                 In  segment INTVEC, offset 0x42, root
   \                     `??EUSCI_A0_ISR::??INTVEC 66`:
   \   000042   ....         DC16    EUSCI_A0_ISR

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for TX_char>`:
   \   000000   ....         DC16 process_buf_rx

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for RX_write>`:
   \   000000   ....         DC16 RING_BUF_A0
    237          //This is a git test
    238          //      switch(baud){
    239          //      case BAUD115200:
    240          //        change_display_line( BAUD115200_STRING,DISPLAY2);
    241          //        //sw2 buton press switch to 460800
    242          //        //sw1 button press transmit current process buffer
    243          //        if(SW1_AND_TOGGLED){
    244          //          SW1_CLEAR;
    245          //          serial_bits = SERIAL_TX; // Sets the flag to chage current buffer in main.
    246          //          //x   strcpy(process_buf_tx,process_buf_rx);
    247          //          UCA0IE |= UCTXIE;
    248          //          //UCA0TXBUF = '\0';
    249          //          //move rx string to tx position
    250          //        }
    251          //        if(SW2_AND_TOGGLED){
    252          //          SW2_CLEAR;
    253          //          baud=BAUD460800;
    254          //          Init_Serial_UCA0(BAUD460800);
    255          //        }
    256          //        break;
    257          //      case BAUD460800:
    258          //        change_display_line( BAUD460800_STRING,DISPLAY2);
    259          //        if(SW1_AND_TOGGLED){
    260          //          SW1_CLEAR;
    261          //          UCA0IE |= UCTXIE;
    262          //          //UCA0TXBUF = '\0';
    263          //        }
    264          //        if(SW2_AND_TOGGLED){
    265          //          SW2_CLEAR;
    266          //          baud=BAUD115200;
    267          //          Init_Serial_UCA0(BAUD115200);
    268          //        }
    269          //        break;
    270          //        
    271          //      }
    272          //      // have two buffer a display buffer and a write buffer.
    273          //      if(update_display==UPDATED){
    274          //        switch(serial_bits&0x7){
    275          //        case SERIAL_WAITING:
    276          //          
    277          //          waiting_animation();
    278          //          
    279          //          break;
    280          //        case SERIAL_RX:
    281          //          change_display_line(RECIVED,DISPLAY0);
    282          //          clear_line(DISPLAY1);
    283          //          change_display_line(process_buf_rx,DISPLAY3);
    284          //          break;
    285          //        case SERIAL_TX:
    286          //          change_display_line(TRASMIT,DISPLAY0);
    287          //          clear_line(DISPLAY3);
    288          //          change_display_line(process_buf_rx,DISPLAY1);
    289          //          break;
    290          //        default:
    291          //          serial_bits = SERIAL_WAITING;
    292          //          break;
    293          //        }
    294          //      }
    295          //    

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      8   EUSCI_A0_ISR
      8   EUSCI_A1_ISR
      4   Init_Serial_UCA0
      4   Init_Serial_UCA1
      4   send


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for RX_write>
       2  ?<Initializer for TX_char>
     252  EUSCI_A0_ISR
       2  EUSCI_A0_ISR::??INTVEC 66
      94  EUSCI_A1_ISR
       2  EUSCI_A1_ISR::??INTVEC 64
     154  Init_Serial_UCA0
     158  Init_Serial_UCA1
      16  RING_BUF_A0
       2  RX_read
       2  RX_write
      16  TX_A1
       2  TX_char
       2  Tx_String
      16  USB_Char_Rx
       2  _A_UCA0BRW_L
       2  _A_UCA0CTLW0_L
       2  _A_UCA0IE_L
       2  _A_UCA0IV_L
       2  _A_UCA0MCTLW_L
       2  _A_UCA0RXBUF_L
       2  _A_UCA0TXBUF_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1IE_L
       2  _A_UCA1IV_L
       2  _A_UCA1MCTLW_L
       2  _A_UCA1RXBUF_L
       2  _A_UCA1TXBUF_L
       2  count
       2  i
      11  process_buf_rx
      11  process_buf_tx
       2  rx_start
      24  send
       1  temp
      11  test_output
       2  usb_rx_ring_wr

 
 336 bytes in segment CODE
  28 bytes in segment DATA16_AN
   4 bytes in segment DATA16_I
   4 bytes in segment DATA16_ID
  94 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 346 bytes in segment ISR_CODE
 
 682 bytes of CODE  memory
   4 bytes of CONST memory (+  4 bytes shared)
  98 bytes of DATA  memory (+ 28 bytes shared)

Errors: none
Warnings: none
