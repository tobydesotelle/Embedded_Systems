###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          28/Nov/2022  20:12:32
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\wheel_control.c
#    Command line  =  
#        -f C:\Users\TOBIAS~1\AppData\Local\Temp\EW9410.tmp ("C:\Users\Tobias
#        Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\wheel_control.c" -lC
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List" -o
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I
#        ./ --core=430X --data_model=small -Ol --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List\wheel_control.lst
#    Object file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj\wheel_control.r43
#
###############################################################################

C:\Users\Tobias Desotelle\OneDrive - UNC Asheville\Documents\GitHub\Embedded_Systems\wheel_control.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains all of the functions that control the wheel
      4          //      movement and state machines for coordnadte movement.
      5          //
      6          //  Tobias Desotelle
      7          //  September 20 2022
      8          //  Built with IAR Embedded Workbench Version: (7.21.1)
      9          //-------------------------------------------------------------------------
     10          #include "macros.h"

   \                                 In  segment DATA16_AN, at 0x3c2
   \   union <unnamed> _A_TB1CCTL0_L
   \                     _A_TB1CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x402
   \   union <unnamed> _A_TB2CCTL0_L
   \                     _A_TB2CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x458
   \   union <unnamed> _A_TB3CCR3_L
   \                     _A_TB3CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x45a
   \   union <unnamed> _A_TB3CCR4_L
   \                     _A_TB3CCR4_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x45c
   \   union <unnamed> _A_TB3CCR5_L
   \                     _A_TB3CCR5_L:
   \   000000                DS8 2
     11          // use state machine for setting movement and delays.
     12          
     13          extern volatile unsigned short motor_control_bits;
     14          extern volatile unsigned short timer_bits;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          unsigned int right_speed;
   \                     right_speed:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          unsigned int left_speed;
   \                     left_speed:
   \   000000                DS8 2
     17          extern unsigned short line_detection;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          unsigned char state;
   \                     state:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          unsigned char check_state;
   \                     check_state:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          PIDController pid;
   \                     pid:
   \   000000                DS8 28

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          char right_wheel_state;//Right and left wheel controller
   \                     right_wheel_state:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          char left_wheel_state;
   \                     left_wheel_state:
   \   000000                DS8 1
     23          #define IDLE		(0x00)
     24          #define Configure_wheel (0x01)
     25          #define Forward_start	(0x02)
     26          #define Reverse_stare	(0x03)
     27          #define Forward_adjust	(0x04)
     28          #define Reverse_adjust	(0x05)
     29          #define Intiate_stop	(0x06)
     30          #define Stop_hold	(0x07)
     31          

   \                                 In  segment CODE, align 2
     32          void right_wheel_statemachine(){
   \                     right_wheel_statemachine:
     33            switch(right_wheel_state){
   \   000000   5E42....     MOV.B   &right_wheel_state, R14
   \   000004   4E83         SUB.B   #0x0, R14
   \   000006   0C24         JEQ     ??right_wheel_statemachine_7
   \   000008   5E83         SUB.B   #0x1, R14
   \   00000A   1024         JEQ     ??right_wheel_statemachine_8
   \   00000C   7E800300     SUB.B   #0x3, R14
   \   000010   1724         JEQ     ??right_wheel_statemachine_9
   \   000012   5E83         SUB.B   #0x1, R14
   \   000014   2D24         JEQ     ??right_wheel_statemachine_10
   \   000016   5E83         SUB.B   #0x1, R14
   \   000018   4324         JEQ     ??right_wheel_statemachine_11
   \   00001A   5E83         SUB.B   #0x1, R14
   \   00001C   4D24         JEQ     ??right_wheel_statemachine_12
   \   00001E   533C         JMP     ??right_wheel_statemachine_6
     34            case IDLE:
     35              if(motor_control_bits & R_MOTOR_STATE)right_wheel_state = Configure_wheel;
   \                     ??right_wheel_statemachine_7:
   \   000020   92B3....     BIT.W   #0x1, &motor_control_bits
   \   000024   5228         JNC     ??right_wheel_statemachine_1
   \   000026   D243....     MOV.B   #0x1, &right_wheel_state
     36              break;
   \   00002A   1001         RETA
     37            case Configure_wheel:
     38              //set_speed(8000);
     39              if(!(motor_control_bits & R_MOTOR_DIR))right_wheel_state = Reverse_adjust;
   \                     ??right_wheel_statemachine_8:
   \   00002C   A2B2....     BIT.W   #0x4, &motor_control_bits
   \   000030   042C         JC      ??right_wheel_statemachine_13
   \   000032   F2400500.... MOV.B   #0x5, &right_wheel_state
   \   000038   1001         RETA
     40              else right_wheel_state =  Forward_adjust;
   \                     ??right_wheel_statemachine_13:
   \   00003A   E242....     MOV.B   #0x4, &right_wheel_state
     41              break;
   \   00003E   1001         RETA
     42            case Forward_adjust:
     43              RIGHT_FORWARD_SPEED = right_speed;
   \                     ??right_wheel_statemachine_9:
   \   000040   9242....5804 MOV.W   &right_speed, &0x458
     44              if(RIGHT_FORWARD_SPEED == 0 || !(motor_control_bits & R_MOTOR_STATE))right_wheel_state = Intiate_stop;
   \   000046   82935804     CMP.W   #0x0, &0x458
   \   00004A   0324         JEQ     ??right_wheel_statemachine_14
   \   00004C   92B3....     BIT.W   #0x1, &motor_control_bits
   \   000050   042C         JC      ??right_wheel_statemachine_15
   \                     ??right_wheel_statemachine_14:
   \   000052   F2400600.... MOV.B   #0x6, &right_wheel_state
   \   000058   1001         RETA
     45              else if( motor_control_bits & R_MOTOR_DIR_CHANGED){
   \                     ??right_wheel_statemachine_15:
   \   00005A   B2B01000.... BIT.W   #0x10, &motor_control_bits
   \   000060   3428         JNC     ??right_wheel_statemachine_1
     46                right_wheel_state = Intiate_stop;
   \   000062   F2400600.... MOV.B   #0x6, &right_wheel_state
     47                motor_control_bits &= ~R_MOTOR_DIR_CHANGED;
   \   000068   B2C01000.... BIC.W   #0x10, &motor_control_bits
     48              }
     49              break;
   \   00006E   1001         RETA
     50            case Reverse_adjust:
     51              RIGHT_REVERSE_SPEED = right_speed;
   \                     ??right_wheel_statemachine_10:
   \   000070   9242....5A04 MOV.W   &right_speed, &0x45a
     52              if(RIGHT_REVERSE_SPEED == 0 || !(motor_control_bits & R_MOTOR_STATE))right_wheel_state = Intiate_stop;
   \   000076   82935A04     CMP.W   #0x0, &0x45a
   \   00007A   0324         JEQ     ??right_wheel_statemachine_16
   \   00007C   92B3....     BIT.W   #0x1, &motor_control_bits
   \   000080   042C         JC      ??right_wheel_statemachine_17
   \                     ??right_wheel_statemachine_16:
   \   000082   F2400600.... MOV.B   #0x6, &right_wheel_state
   \   000088   1001         RETA
     53              else if( motor_control_bits & R_MOTOR_DIR_CHANGED){
   \                     ??right_wheel_statemachine_17:
   \   00008A   B2B01000.... BIT.W   #0x10, &motor_control_bits
   \   000090   1C28         JNC     ??right_wheel_statemachine_1
     54                right_wheel_state = Intiate_stop;
   \   000092   F2400600.... MOV.B   #0x6, &right_wheel_state
     55                motor_control_bits &= ~R_MOTOR_DIR_CHANGED;
   \   000098   B2C01000.... BIC.W   #0x10, &motor_control_bits
     56              }
     57              break;
   \   00009E   1001         RETA
     58            case Intiate_stop:
     59              RIGHT_FORWARD_SPEED = 0;
   \                     ??right_wheel_statemachine_11:
   \   0000A0   82435804     MOV.W   #0x0, &0x458
     60              RIGHT_REVERSE_SPEED = 0;
   \   0000A4   82435A04     MOV.W   #0x0, &0x45a
     61              motor_control_bits &= ~R_MOTOR_STATE;
   \   0000A8   92C3....     BIC.W   #0x1, &motor_control_bits
     62              TB2CCTL0 |= CCIE;
   \   0000AC   B2D010000204 BIS.W   #0x10, &0x402
     63              right_wheel_state = Stop_hold;
   \   0000B2   F2400700.... MOV.B   #0x7, &right_wheel_state
     64            case Stop_hold:
     65              if(timer_bits & Change_wheel_state)right_wheel_state = IDLE; //BUG here or something
   \                     ??right_wheel_statemachine_12:
   \   0000B8   B2B02000.... BIT.W   #0x20, &timer_bits
   \   0000BE   0528         JNC     ??right_wheel_statemachine_1
   \   0000C0   C243....     MOV.B   #0x0, &right_wheel_state
     66              break;
   \   0000C4   1001         RETA
     67            default:
     68              right_wheel_state = IDLE;
   \                     ??right_wheel_statemachine_6:
   \   0000C6   C243....     MOV.B   #0x0, &right_wheel_state
     69              break;
     70            }
     71            
     72          }
   \                     ??right_wheel_statemachine_1:
   \   0000CA   1001         RETA
   \   0000CC                REQUIRE _A_TB3CCR3_L
   \   0000CC                REQUIRE _A_TB3CCR4_L
   \   0000CC                REQUIRE _A_TB2CCTL0_L

   \                                 In  segment CODE, align 2
     73          void left_wheel_statemachine(){
   \                     left_wheel_statemachine:
     74            switch(left_wheel_state){
   \   000000   5E42....     MOV.B   &left_wheel_state, R14
   \   000004   4E83         SUB.B   #0x0, R14
   \   000006   0C24         JEQ     ??left_wheel_statemachine_7
   \   000008   5E83         SUB.B   #0x1, R14
   \   00000A   1024         JEQ     ??left_wheel_statemachine_8
   \   00000C   7E800300     SUB.B   #0x3, R14
   \   000010   1724         JEQ     ??left_wheel_statemachine_9
   \   000012   5E83         SUB.B   #0x1, R14
   \   000014   2D24         JEQ     ??left_wheel_statemachine_10
   \   000016   5E83         SUB.B   #0x1, R14
   \   000018   4324         JEQ     ??left_wheel_statemachine_11
   \   00001A   5E83         SUB.B   #0x1, R14
   \   00001C   4D24         JEQ     ??left_wheel_statemachine_12
   \   00001E   533C         JMP     ??left_wheel_statemachine_6
     75            case IDLE:
     76              if(motor_control_bits & R_MOTOR_STATE)left_wheel_state = Configure_wheel;
   \                     ??left_wheel_statemachine_7:
   \   000020   92B3....     BIT.W   #0x1, &motor_control_bits
   \   000024   5228         JNC     ??left_wheel_statemachine_1
   \   000026   D243....     MOV.B   #0x1, &left_wheel_state
     77              break;
   \   00002A   1001         RETA
     78            case Configure_wheel:
     79              //set_speed(8000);
     80              if(!(motor_control_bits & L_MOTOR_DIR))left_wheel_state =  Reverse_adjust;
   \                     ??left_wheel_statemachine_8:
   \   00002C   B2B2....     BIT.W   #0x8, &motor_control_bits
   \   000030   042C         JC      ??left_wheel_statemachine_13
   \   000032   F2400500.... MOV.B   #0x5, &left_wheel_state
   \   000038   1001         RETA
     81              else left_wheel_state = Forward_adjust;
   \                     ??left_wheel_statemachine_13:
   \   00003A   E242....     MOV.B   #0x4, &left_wheel_state
     82              break;
   \   00003E   1001         RETA
     83            case Forward_adjust:
     84              LEFT_FORWARD_SPEED = left_speed;
   \                     ??left_wheel_statemachine_9:
   \   000040   9242....5404 MOV.W   &left_speed, &0x454
     85              if(LEFT_FORWARD_SPEED == 0 || !(motor_control_bits & L_MOTOR_STATE))left_wheel_state = Intiate_stop;
   \   000046   82935404     CMP.W   #0x0, &0x454
   \   00004A   0324         JEQ     ??left_wheel_statemachine_14
   \   00004C   A2B3....     BIT.W   #0x2, &motor_control_bits
   \   000050   042C         JC      ??left_wheel_statemachine_15
   \                     ??left_wheel_statemachine_14:
   \   000052   F2400600.... MOV.B   #0x6, &left_wheel_state
   \   000058   1001         RETA
     86              else if( motor_control_bits & L_MOTOR_DIR_CHANGED){
   \                     ??left_wheel_statemachine_15:
   \   00005A   B2B02000.... BIT.W   #0x20, &motor_control_bits
   \   000060   3428         JNC     ??left_wheel_statemachine_1
     87                left_wheel_state = Intiate_stop;
   \   000062   F2400600.... MOV.B   #0x6, &left_wheel_state
     88                motor_control_bits &= ~L_MOTOR_DIR_CHANGED;
   \   000068   B2C02000.... BIC.W   #0x20, &motor_control_bits
     89              }
     90              break;
   \   00006E   1001         RETA
     91            case Reverse_adjust:
     92              LEFT_REVERSE_SPEED = left_speed;
   \                     ??left_wheel_statemachine_10:
   \   000070   9242....5604 MOV.W   &left_speed, &0x456
     93              if(LEFT_REVERSE_SPEED == 0 || !(motor_control_bits & L_MOTOR_STATE))left_wheel_state = Intiate_stop;
   \   000076   82935604     CMP.W   #0x0, &0x456
   \   00007A   0324         JEQ     ??left_wheel_statemachine_16
   \   00007C   A2B3....     BIT.W   #0x2, &motor_control_bits
   \   000080   042C         JC      ??left_wheel_statemachine_17
   \                     ??left_wheel_statemachine_16:
   \   000082   F2400600.... MOV.B   #0x6, &left_wheel_state
   \   000088   1001         RETA
     94              else if( motor_control_bits & L_MOTOR_DIR_CHANGED){
   \                     ??left_wheel_statemachine_17:
   \   00008A   B2B02000.... BIT.W   #0x20, &motor_control_bits
   \   000090   1C28         JNC     ??left_wheel_statemachine_1
     95                left_wheel_state = Intiate_stop;
   \   000092   F2400600.... MOV.B   #0x6, &left_wheel_state
     96                motor_control_bits &= ~L_MOTOR_DIR_CHANGED;
   \   000098   B2C02000.... BIC.W   #0x20, &motor_control_bits
     97              }
     98              break;
   \   00009E   1001         RETA
     99            case Intiate_stop:
    100              LEFT_FORWARD_SPEED = 0;
   \                     ??left_wheel_statemachine_11:
   \   0000A0   82435404     MOV.W   #0x0, &0x454
    101              LEFT_REVERSE_SPEED = 0;
   \   0000A4   82435604     MOV.W   #0x0, &0x456
    102              motor_control_bits &= ~L_MOTOR_STATE;
   \   0000A8   A2C3....     BIC.W   #0x2, &motor_control_bits
    103              TB2CCTL0 |= CCIE;
   \   0000AC   B2D010000204 BIS.W   #0x10, &0x402
    104              left_wheel_state = Stop_hold;
   \   0000B2   F2400700.... MOV.B   #0x7, &left_wheel_state
    105            case Stop_hold:
    106              if(timer_bits & Change_wheel_state)left_wheel_state = IDLE;
   \                     ??left_wheel_statemachine_12:
   \   0000B8   B2B02000.... BIT.W   #0x20, &timer_bits
   \   0000BE   0528         JNC     ??left_wheel_statemachine_1
   \   0000C0   C243....     MOV.B   #0x0, &left_wheel_state
    107              break;
   \   0000C4   1001         RETA
    108            default:
    109              left_wheel_state = IDLE;
   \                     ??left_wheel_statemachine_6:
   \   0000C6   C243....     MOV.B   #0x0, &left_wheel_state
    110              break;
    111            }
    112            
    113          }
   \                     ??left_wheel_statemachine_1:
   \   0000CA   1001         RETA
   \   0000CC                REQUIRE _A_TB3CCR1_L
   \   0000CC                REQUIRE _A_TB3CCR2_L
   \   0000CC                REQUIRE _A_TB2CCTL0_L

   \                                 In  segment CODE, align 2
    114          void move(unsigned short movement_bits){
   \                     move:
    115            motor_control_bits = movement_bits; 
   \   000000   824C....     MOV.W   R12, &motor_control_bits
    116            if((motor_control_bits & R_MOTOR_DIR) != (movement_bits & R_MOTOR_DIR)) motor_control_bits |= R_MOTOR_DIR_CHANGED;
   \   000004   1E42....     MOV.W   &motor_control_bits, R14
   \   000008   6EF2         AND.B   #0x4, R14
   \   00000A   0F12         PUSH.W  R15
   \   00000C   C14C0000     MOV.B   R12, 0(SP)
   \   000010   3F41         POP.W   R15
   \   000012   6FF2         AND.B   #0x4, R15
   \   000014   4E9F         CMP.B   R15, R14
   \   000016   0324         JEQ     ??move_0
   \   000018   B2D01000.... BIS.W   #0x10, &motor_control_bits
    117            if((motor_control_bits & L_MOTOR_DIR) != (movement_bits & L_MOTOR_DIR)) motor_control_bits |= L_MOTOR_DIR_CHANGED;
   \                     ??move_0:
   \   00001E   1E42....     MOV.W   &motor_control_bits, R14
   \   000022   7EF2         AND.B   #0x8, R14
   \   000024   7CF2         AND.B   #0x8, R12
   \   000026   4E9C         CMP.B   R12, R14
   \   000028   0324         JEQ     ??move_1
   \   00002A   B2D02000.... BIS.W   #0x20, &motor_control_bits
    118            //else 
    119            left_wheel_statemachine();
   \                     ??move_1:
   \   000030   ........     CALLA   #left_wheel_statemachine
    120            right_wheel_statemachine();
   \   000034   ........     CALLA   #right_wheel_statemachine
    121          }
   \   000038   1001         RETA

   \                                 In  segment CODE, align 2
    122          void set_speed(unsigned int speed){
   \                     set_speed:
    123            right_speed=speed;
   \   000000   824C....     MOV.W   R12, &right_speed
    124            left_speed=speed;
   \   000004   824C....     MOV.W   R12, &left_speed
    125          }
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    126          void set_right_speed(unsigned int speed){
   \                     set_right_speed:
    127            right_speed=speed;
   \   000000   824C....     MOV.W   R12, &right_speed
    128          }
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    129          void set_left_speed(unsigned int speed){
   \                     set_left_speed:
    130            left_speed=speed;
   \   000000   824C....     MOV.W   R12, &left_speed
    131          }
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    132          void enable_ramp_to(unsigned int setpoint){
   \                     enable_ramp_to:
    133            if(setpoint>BACKLIGHT)ramp_up_to(setpoint);
   \   000000   829C5C04     CMP.W   R12, &0x45c
   \   000004   022C         JC      ??enable_ramp_to_0
   \   000006   ........     CALLA   #ramp_up_to
    134            
    135          }
   \                     ??enable_ramp_to_0:
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_TB3CCR5_L

   \                                 In  segment CODE, align 2
    136          void ramp_up_to(unsigned int setpoint){
   \                     ramp_up_to:
    137            //enable timer 1 to increase pwm value
    138            TB1CCTL0 &= ~CCIFG; // CCR0 enable interrupt
   \   000000   92C3C203     BIC.W   #0x1, &0x3c2
    139            TB1CCTL0 |= CCIE; // CCR0 enable interrupt
   \   000004   B2D01000C203 BIS.W   #0x10, &0x3c2
    140            //speed=setpoint;
    141          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_TB1CCTL0_L

   \                                 In  segment CODE, align 2
    142          void stop(){
   \                     stop:
    143            set_speed(0);
   \   000000   0C43         MOV.W   #0x0, R12
   \   000002   ........     CALLA   #set_speed
    144            RIGHT_FORWARD_SPEED = WHEEL_OFF;
   \   000006   82435804     MOV.W   #0x0, &0x458
    145            RIGHT_REVERSE_SPEED = WHEEL_OFF;
   \   00000A   82435A04     MOV.W   #0x0, &0x45a
    146            LEFT_FORWARD_SPEED = WHEEL_OFF;
   \   00000E   82435404     MOV.W   #0x0, &0x454
    147            LEFT_REVERSE_SPEED = WHEEL_OFF;
   \   000012   82435604     MOV.W   #0x0, &0x456
    148          }
   \   000016   1001         RETA
   \   000018                REQUIRE _A_TB3CCR3_L
   \   000018                REQUIRE _A_TB3CCR4_L
   \   000018                REQUIRE _A_TB3CCR1_L
   \   000018                REQUIRE _A_TB3CCR2_L

   \                                 In  segment CODE, align 2
    149          void Wheels_Process(void){
   \                     Wheels_Process:
    150            //------------------------------------------------------
    151            process_detectors();
   \   000000   ........     CALLA   #process_detectors
    152            switch(state){
   \   000004   5E42....     MOV.B   &state, R14
   \   000008   4E83         SUB.B   #0x0, R14
   \   00000A   0E24         JEQ     ??Wheels_Process_3
   \   00000C   5E83         SUB.B   #0x1, R14
   \   00000E   1624         JEQ     ??Wheels_Process_4
   \   000010   5E83         SUB.B   #0x1, R14
   \   000012   2324         JEQ     ??Wheels_Process_5
   \   000014   5E83         SUB.B   #0x1, R14
   \   000016   2C24         JEQ     ??Wheels_Process_6
   \   000018   5E83         SUB.B   #0x1, R14
   \   00001A   3624         JEQ     ??Wheels_Process_7
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   4F24         JEQ     ??Wheels_Process_8
   \   000020   7E803F00     SUB.B   #0x3f, R14
   \   000024   5C24         JEQ     ??Wheels_Process_1
   \   000026   593C         JMP     ??Wheels_Process_2
    153            case IDLE: // IDLE
    154              stop();
   \                     ??Wheels_Process_3:
   \   000028   ........     CALLA   #stop
    155              set_speed(BASE_SPEED);
   \   00002C   3C409A10     MOV.W   #0x109a, R12
   \   000030   ........     CALLA   #set_speed
    156              idle_case(START);
   \   000034   5C43         MOV.B   #0x1, R12
   \   000036   ........     CALLA   #idle_case
    157              break; 
   \   00003A   1001         RETA
    158            case START: 
    159              move(FORWARD);
   \                     ??Wheels_Process_4:
   \   00003C   3C400300     MOV.W   #0x3, R12
   \   000040   ........     CALLA   #move
    160              do_for(&state,IDLE,100);
   \   000044   3E406400     MOV.W   #0x64, R14
   \   000048   4D43         MOV.B   #0x0, R13
   \   00004A   3C40....     MOV.W   #state, R12
   \   00004E   ........     CALLA   #do_for
    161              search(LINE_FOUND);
   \   000052   6C43         MOV.B   #0x2, R12
   \   000054   ........     CALLA   #search
    162              break;
   \   000058   1001         RETA
    163            case LINE_FOUND: 
    164              stop();
   \                     ??Wheels_Process_5:
   \   00005A   ........     CALLA   #stop
    165              do_for(&state,BACK_UP,50);
   \   00005E   3E403200     MOV.W   #0x32, R14
   \   000062   7D400300     MOV.B   #0x3, R13
   \   000066   3C40....     MOV.W   #state, R12
   \   00006A   ........     CALLA   #do_for
    166              //P6OUT |=GRN_LED;
    167              break;
   \   00006E   1001         RETA
    168            case BACK_UP: 
    169              move(FORWARD);
   \                     ??Wheels_Process_6:
   \   000070   3C400300     MOV.W   #0x3, R12
   \   000074   ........     CALLA   #move
    170              do_for(&state,ALIGN,10);
   \   000078   3E400A00     MOV.W   #0xa, R14
   \   00007C   6D42         MOV.B   #0x4, R13
   \   00007E   3C40....     MOV.W   #state, R12
   \   000082   ........     CALLA   #do_for
    171              break;
   \   000086   1001         RETA
    172            case ALIGN: //Spin until both sensor read strong 
    173              set_speed(BASE_SPEED);
   \                     ??Wheels_Process_7:
   \   000088   3C409A10     MOV.W   #0x109a, R12
   \   00008C   ........     CALLA   #set_speed
    174              move(CW);
   \   000090   3C400700     MOV.W   #0x7, R12
   \   000094   ........     CALLA   #move
    175              if(line_detection>=0X44){
   \   000098   B2904400.... CMP.W   #0x44, &line_detection
   \   00009E   0728         JNC     ??Wheels_Process_9
    176                state = PID;
   \   0000A0   F2400500.... MOV.B   #0x5, &state
    177                PIDController_Init(&pid);
   \   0000A6   3C40....     MOV.W   #pid, R12
   \   0000AA   ........     CALLA   #PIDController_Init
    178              }
    179              //check_state=START;
    180              do_for(&state,IDLE,1000);
   \                     ??Wheels_Process_9:
   \   0000AE   3E40E803     MOV.W   #0x3e8, R14
   \   0000B2   4D43         MOV.B   #0x0, R13
   \   0000B4   3C40....     MOV.W   #state, R12
   \   0000B8   ........     CALLA   #do_for
    181              break;
   \   0000BC   1001         RETA
    182            case PID : // Adjust Reverse
    183              move(FORWARD);
   \                     ??Wheels_Process_8:
   \   0000BE   3C400300     MOV.W   #0x3, R12
   \   0000C2   ........     CALLA   #move
    184              pid_control();
   \   0000C6   ........     CALLA   #pid_control
    185              do_for(&state,IDLE,1000);
   \   0000CA   3E40E803     MOV.W   #0x3e8, R14
   \   0000CE   4D43         MOV.B   #0x0, R13
   \   0000D0   3C40....     MOV.W   #state, R12
   \   0000D4   ........     CALLA   #do_for
    186              break;  
   \   0000D8   1001         RETA
    187            case Stop: // Look for End of Stop Time
    188              break; 
    189            default:
    190              state = IDLE;
   \                     ??Wheels_Process_2:
   \   0000DA   C243....     MOV.B   #0x0, &state
    191              break;
    192            }
    193          }
   \                     ??Wheels_Process_1:
   \   0000DE   1001         RETA

   \                                 In  segment CODE, align 2
    194          void pid_control(){
   \                     pid_control:
    195            //Want to update pid loop and set output
    196            int Motor_offset = PIDController_Update(&pid,0,measurment());
   \   000000   ........     CALLA   #measurment
   \   000004   0E4C         MOV.W   R12, R14
   \   000006   0D43         MOV.W   #0x0, R13
   \   000008   3C40....     MOV.W   #pid, R12
   \   00000C   ........     CALLA   #PIDController_Update
   \   000010   0F4C         MOV.W   R12, R15
    197            set_left_speed(BASE_SPEED-(unsigned int)Motor_offset);
   \   000012   3C409A10     MOV.W   #0x109a, R12
   \   000016   0C8F         SUB.W   R15, R12
   \   000018   ........     CALLA   #set_left_speed
    198            set_right_speed(BASE_SPEED+(unsigned int)Motor_offset);
   \   00001C   3F509A10     ADD.W   #0x109a, R15
   \   000020   0C4F         MOV.W   R15, R12
   \   000022   ........     CALLA   #set_right_speed
    199            
    200          }
   \   000026   1001         RETA

   \                                 In  segment CODE, align 2
    201          void pid_test(){
   \                     pid_test:
    202            
    203            
    204          }
   \   000000   1001         RETA
    205          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Wheels_Process
        4   -> PIDController_Init
        4   -> do_for
        4   -> idle_case
        4   -> move
        4   -> pid_control
        4   -> process_detectors
        4   -> search
        4   -> set_speed
        4   -> stop
      4   enable_ramp_to
        4   -> ramp_up_to
      4   left_wheel_statemachine
      6   move
        4   -> left_wheel_statemachine
        4   -> right_wheel_statemachine
      4   pid_control
        4   -> PIDController_Update
        4   -> measurment
        4   -> set_left_speed
        4   -> set_right_speed
      4   pid_test
      4   ramp_up_to
      4   right_wheel_statemachine
      4   set_left_speed
      4   set_right_speed
      4   set_speed
      4   stop
        4   -> set_speed


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     224  Wheels_Process
       2  _A_TB1CCTL0_L
       2  _A_TB2CCTL0_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
       2  _A_TB3CCR3_L
       2  _A_TB3CCR4_L
       2  _A_TB3CCR5_L
       1  check_state
      12  enable_ramp_to
       2  left_speed
       1  left_wheel_state
     204  left_wheel_statemachine
      58  move
      28  pid
      40  pid_control
       2  pid_test
      12  ramp_up_to
       2  right_speed
       1  right_wheel_state
     204  right_wheel_statemachine
       6  set_left_speed
       6  set_right_speed
      10  set_speed
       1  state
      24  stop

 
 802 bytes in segment CODE
  14 bytes in segment DATA16_AN
  36 bytes in segment DATA16_Z
 
 802 bytes of CODE memory
  36 bytes of DATA memory (+ 14 bytes shared)

Errors: none
Warnings: none
