###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          11/Nov/2022  23:33:20
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\wheel_control.c
#    Command line  =  
#        -f C:\Users\TOBIAS~1\AppData\Local\Temp\EW9308.tmp ("C:\Users\Tobias
#        Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\wheel_control.c" -lC
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List" -o
#        "C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I
#        ./ --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\List\wheel_control.lst
#    Object file   =  
#        C:\Users\Tobias Desotelle\OneDrive - UNC
#        Asheville\Documents\GitHub\Embedded_Systems\Debug\Obj\wheel_control.r43
#
###############################################################################

C:\Users\Tobias Desotelle\OneDrive - UNC Asheville\Documents\GitHub\Embedded_Systems\wheel_control.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains all of the functions that control the wheel
      4          //      movement and state machines for coordnadte movement.
      5          //
      6          //  Tobias Desotelle
      7          //  September 20 2022
      8          //  Built with IAR Embedded Workbench Version: (7.21.1)
      9          //-------------------------------------------------------------------------
     10          #include "macros.h"

   \                                 In  segment DATA16_AN, at 0x386
   \   union <unnamed> _A_TB0CCTL2_L
   \                     _A_TB0CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x396
   \   union <unnamed> _A_TB0CCR2_L
   \                     _A_TB0CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c2
   \   union <unnamed> _A_TB1CCTL0_L
   \                     _A_TB1CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x458
   \   union <unnamed> _A_TB3CCR3_L
   \                     _A_TB3CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x45a
   \   union <unnamed> _A_TB3CCR4_L
   \                     _A_TB3CCR4_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x45c
   \   union <unnamed> _A_TB3CCR5_L
   \                     _A_TB3CCR5_L:
   \   000000                DS8 2
     11          // use state machine for setting movement and delays.
     12          
     13          extern volatile unsigned short motor_control_bits;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     14          unsigned int right_speed;
   \                     right_speed:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          unsigned int left_speed;
   \                     left_speed:
   \   000000                DS8 2
     16          extern unsigned short line_detection;
     17          extern unsigned char state;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          unsigned char check_state;
   \                     check_state:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          PIDController pid;
   \                     pid:
   \   000000                DS8 56
     20          
     21          /*
     22          //#define R_MOTOR_STATE       (0x01)// 0 = off / 1 = on
     23          //#define L_MOTOR_STATE       (0x02)// 0 = off / 1 = on
     24          //#define R_MOTOR_DIR         (0x04)// 0 = forward / 1 = reverse
     25          //#define L_MOTOR_DIR         (0x08)// 0 = forward / 1 = reverse
     26          //#define R_MOTOR_DIR_CHANGED (0X10)// will be set if direction changed and safey flag not met
     27          //#define R_MOTOR_DIR_CHANGED (0X20)// will be set if direction changed and safey flag not met
     28          //#define R_MOTOR_SPD_CHANGED (0X40)//
     29          //#define L_MOTOR_SPD_CHANGED (0X80)
     30          Things needed delay when changing wheels
     31          wheel selection
     32          Timed wheel movement for consistancy
     33          
     34          
     35          simple movement i.e.(forwards, backwards, CW, CCW)
     36          
     37          
     38          */

   \                                 In  segment CODE, align 2
     39          void move(unsigned short movement_bits){
   \                     move:
   \   000000   0D4C         MOV.W   R12, R13
     40            changed_check(movement_bits);//checks if motor direction has changed
   \   000002   0C4D         MOV.W   R13, R12
   \   000004   ........     CALLA   #changed_check
     41            delay_motor();//delay if motor direction has changed
   \   000008   ........     CALLA   #delay_motor
     42            process_wheels(movement_bits);//send move command if motor direction has changed or speed has changed
   \   00000C   0C4D         MOV.W   R13, R12
   \   00000E   ........     CALLA   #process_wheels
     43          }
   \   000012   1001         RETA

   \                                 In  segment CODE, align 2
     44          void changed_check(unsigned short movement_bits){
   \                     changed_check:
     45              if((motor_control_bits&0x0f)==movement_bits){//if the movement is the same
   \   000000   1F42....     MOV.W   &motor_control_bits, R15
   \   000004   3FF00F00     AND.W   #0xf, R15
   \   000008   0F9C         CMP.W   R12, R15
   \   00000A   1A24         JEQ     ??changed_check_0
     46              //this is if the movement doesn't change the direction
     47            }
     48            else{//if a wheel has changed direction
     49              if(((motor_control_bits&R_MOTOR_DIR)!=(movement_bits&R_MOTOR_DIR))){
   \   00000C   1E42....     MOV.W   &motor_control_bits, R14
   \   000010   6EF2         AND.B   #0x4, R14
   \   000012   0F12         PUSH.W  R15
   \   000014   C14C0000     MOV.B   R12, 0(SP)
   \   000018   3F41         POP.W   R15
   \   00001A   6FF2         AND.B   #0x4, R15
   \   00001C   4E9F         CMP.B   R15, R14
   \   00001E   0324         JEQ     ??changed_check_1
     50                motor_control_bits |= R_MOTOR_DIR_CHANGED ;
   \   000020   B2D01000.... BIS.W   #0x10, &motor_control_bits
     51              }
     52              if(((motor_control_bits&L_MOTOR_DIR)!=(movement_bits&L_MOTOR_DIR))){
   \                     ??changed_check_1:
   \   000026   1E42....     MOV.W   &motor_control_bits, R14
   \   00002A   7EF2         AND.B   #0x8, R14
   \   00002C   0F12         PUSH.W  R15
   \   00002E   C14C0000     MOV.B   R12, 0(SP)
   \   000032   3F41         POP.W   R15
   \   000034   7FF2         AND.B   #0x8, R15
   \   000036   4E9F         CMP.B   R15, R14
   \   000038   0324         JEQ     ??changed_check_0
     53                motor_control_bits |= L_MOTOR_DIR_CHANGED ;
   \   00003A   B2D02000.... BIS.W   #0x20, &motor_control_bits
     54              }
     55            }
     56            
     57          }
   \                     ??changed_check_0:
   \   000040   1001         RETA

   \                                 In  segment CODE, align 2
     58          void delay_motor(){
   \                     delay_motor:
     59            if(motor_control_bits&R_MOTOR_DIR_CHANGED||motor_control_bits&L_MOTOR_DIR_CHANGED){
   \   000000   B2B01000.... BIT.W   #0x10, &motor_control_bits
   \   000006   042C         JC      ??delay_motor_0
   \   000008   B2B02000.... BIT.W   #0x20, &motor_control_bits
   \   00000E   2628         JNC     ??delay_motor_1
     60              //start a timer
     61              if(motor_control_bits&R_MOTOR_DIR_CHANGED){
   \                     ??delay_motor_0:
   \   000010   B2B01000.... BIT.W   #0x10, &motor_control_bits
   \   000016   0928         JNC     ??delay_motor_2
     62                motor_control_bits &= ~R_MOTOR_STATE;
   \   000018   92C3....     BIC.W   #0x1, &motor_control_bits
     63                motor_control_bits &= ~R_MOTOR_DIR_CHANGED;
   \   00001C   B2C01000.... BIC.W   #0x10, &motor_control_bits
     64                RIGHT_FORWARD_SPEED = WHEEL_OFF;
   \   000022   82435604     MOV.W   #0x0, &0x456
     65                RIGHT_REVERSE_SPEED = WHEEL_OFF;
   \   000026   82435404     MOV.W   #0x0, &0x454
     66              }
     67              if(motor_control_bits&L_MOTOR_DIR_CHANGED){
   \                     ??delay_motor_2:
   \   00002A   B2B02000.... BIT.W   #0x20, &motor_control_bits
   \   000030   0928         JNC     ??delay_motor_3
     68                motor_control_bits &= ~L_MOTOR_STATE;
   \   000032   A2C3....     BIC.W   #0x2, &motor_control_bits
     69                motor_control_bits &= ~L_MOTOR_DIR_CHANGED;
   \   000036   B2C02000.... BIC.W   #0x20, &motor_control_bits
     70                LEFT_FORWARD_SPEED = WHEEL_OFF;
   \   00003C   82435A04     MOV.W   #0x0, &0x45a
     71                LEFT_REVERSE_SPEED = WHEEL_OFF;
   \   000040   82435804     MOV.W   #0x0, &0x458
     72              }
     73              if(TB0CCTL2!=CCIE){
   \                     ??delay_motor_3:
   \   000044   B29010008603 CMP.W   #0x10, &0x386
   \   00004A   0824         JEQ     ??delay_motor_1
     74                TB0CCR2 += TB0CCR2_INTERVAL;
   \   00004C   B250A8619603 ADD.W   #0x61a8, &0x396
     75                TB0CCTL2 &= ~CCIFG;//enable wheel delay timer
   \   000052   92C38603     BIC.W   #0x1, &0x386
     76                TB0CCTL2 |= CCIE;
   \   000056   B2D010008603 BIS.W   #0x10, &0x386
     77              }
     78            }
     79          }
   \                     ??delay_motor_1:
   \   00005C   1001         RETA
   \   00005E                REQUIRE _A_TB3CCR2_L
   \   00005E                REQUIRE _A_TB3CCR1_L
   \   00005E                REQUIRE _A_TB3CCR4_L
   \   00005E                REQUIRE _A_TB3CCR3_L
   \   00005E                REQUIRE _A_TB0CCTL2_L
   \   00005E                REQUIRE _A_TB0CCR2_L

   \                                 In  segment CODE, align 2
     80          void process_wheels(unsigned short movement_bits){
   \                     process_wheels:
     81            motor_control_bits &= 0x00;
   \   000000   1F42....     MOV.W   &motor_control_bits, R15
   \   000004   8243....     MOV.W   #0x0, &motor_control_bits
     82            motor_control_bits |= movement_bits;
   \   000008   82DC....     BIS.W   R12, &motor_control_bits
     83            if((motor_control_bits&WHEELS_ON==WHEELS_ON)/*&&(motor_control_bits&!WHEELS_DIR_CHANGED)*/){  
   \   00000C   92B3....     BIT.W   #0x1, &motor_control_bits
   \   000010   3328         JNC     ??process_wheels_1
     84              switch((motor_control_bits&DIR_MASK)){//>>2
   \   000012   1E42....     MOV.W   &motor_control_bits, R14
   \   000016   7EF00F00     AND.B   #0xf, R14
   \   00001A   5E83         SUB.B   #0x1, R14
   \   00001C   0924         JEQ     ??process_wheels_2
   \   00001E   6E83         SUB.B   #0x2, R14
   \   000020   0D24         JEQ     ??process_wheels_3
   \   000022   6E82         SUB.B   #0x4, R14
   \   000024   2024         JEQ     ??process_wheels_4
   \   000026   6E82         SUB.B   #0x4, R14
   \   000028   1024         JEQ     ??process_wheels_5
   \   00002A   6E82         SUB.B   #0x4, R14
   \   00002C   1524         JEQ     ??process_wheels_6
   \   00002E   223C         JMP     ??process_wheels_0
     85              case PIVOT_F_L:
     86                RIGHT_FORWARD_SPEED = right_speed;
   \                     ??process_wheels_2:
   \   000030   9242....5604 MOV.W   &right_speed, &0x456
     87                LEFT_FORWARD_SPEED = WHEEL_OFF;
   \   000036   82435A04     MOV.W   #0x0, &0x45a
     88                break;
   \   00003A   1001         RETA
     89              case BOTH_FORWARD:
     90                RIGHT_FORWARD_SPEED = right_speed;
   \                     ??process_wheels_3:
   \   00003C   9242....5604 MOV.W   &right_speed, &0x456
     91                LEFT_FORWARD_SPEED = left_speed;
   \   000042   9242....5A04 MOV.W   &left_speed, &0x45a
     92                break;
   \   000048   1001         RETA
     93              case CCW:
     94                RIGHT_FORWARD_SPEED = right_speed;
   \                     ??process_wheels_5:
   \   00004A   9242....5604 MOV.W   &right_speed, &0x456
     95                LEFT_REVERSE_SPEED = left_speed;
   \   000050   9242....5804 MOV.W   &left_speed, &0x458
     96                break;
   \   000056   1001         RETA
     97              case BOTH_REVERSE:
     98                RIGHT_REVERSE_SPEED = right_speed;
   \                     ??process_wheels_6:
   \   000058   9242....5404 MOV.W   &right_speed, &0x454
     99                LEFT_REVERSE_SPEED = left_speed;
   \   00005E   9242....5804 MOV.W   &left_speed, &0x458
    100                break;
   \   000064   1001         RETA
    101              case CW:
    102                LEFT_FORWARD_SPEED = right_speed;
   \                     ??process_wheels_4:
   \   000066   9242....5A04 MOV.W   &right_speed, &0x45a
    103                RIGHT_REVERSE_SPEED = left_speed;
   \   00006C   9242....5404 MOV.W   &left_speed, &0x454
    104                break;
   \   000072   1001         RETA
    105              default:
    106                stop();
   \                     ??process_wheels_0:
   \   000074   ........     CALLA   #stop
    107                break;
    108              }
    109            }
    110          }
   \                     ??process_wheels_1:
   \   000078   1001         RETA
   \   00007A                REQUIRE _A_TB3CCR2_L
   \   00007A                REQUIRE _A_TB3CCR4_L
   \   00007A                REQUIRE _A_TB3CCR3_L
   \   00007A                REQUIRE _A_TB3CCR1_L
    111          void speed_change();
    112          void direction_change(); //if direction change rise flag and start a timer 

   \                                 In  segment CODE, align 2
    113          void set_speed(unsigned int speed){
   \                     set_speed:
    114            right_speed=speed;
   \   000000   824C....     MOV.W   R12, &right_speed
    115            left_speed=speed;
   \   000004   824C....     MOV.W   R12, &left_speed
    116          }
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    117          void set_right_speed(unsigned int speed){
   \                     set_right_speed:
    118            right_speed=speed;
   \   000000   824C....     MOV.W   R12, &right_speed
    119          }
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    120          void set_left_speed(unsigned int speed){
   \                     set_left_speed:
    121            left_speed=speed;
   \   000000   824C....     MOV.W   R12, &left_speed
    122          }
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    123          void enable_ramp_to(unsigned int setpoint){
   \                     enable_ramp_to:
   \   000000   0F4C         MOV.W   R12, R15
    124            if(setpoint>BACKLIGHT)ramp_up_to(setpoint);
   \   000002   829F5C04     CMP.W   R15, &0x45c
   \   000006   032C         JC      ??enable_ramp_to_0
   \   000008   0C4F         MOV.W   R15, R12
   \   00000A   ........     CALLA   #ramp_up_to
    125            
    126          }
   \                     ??enable_ramp_to_0:
   \   00000E   1001         RETA
   \   000010                REQUIRE _A_TB3CCR5_L

   \                                 In  segment CODE, align 2
    127          void ramp_up_to(unsigned int setpoint){
   \                     ramp_up_to:
    128            //enable timer 1 to increase pwm value
    129            TB1CCTL0 &= ~CCIFG; // CCR0 enable interrupt
   \   000000   92C3C203     BIC.W   #0x1, &0x3c2
    130            TB1CCTL0 |= CCIE; // CCR0 enable interrupt
   \   000004   B2D01000C203 BIS.W   #0x10, &0x3c2
    131            //speed=setpoint;
    132          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_TB1CCTL0_L

   \                                 In  segment CODE, align 2
    133          void stop(){
   \                     stop:
    134            RIGHT_FORWARD_SPEED = WHEEL_OFF;
   \   000000   82435604     MOV.W   #0x0, &0x456
    135            RIGHT_REVERSE_SPEED = WHEEL_OFF;
   \   000004   82435404     MOV.W   #0x0, &0x454
    136            LEFT_FORWARD_SPEED = WHEEL_OFF;
   \   000008   82435A04     MOV.W   #0x0, &0x45a
    137            LEFT_REVERSE_SPEED = WHEEL_OFF;
   \   00000C   82435804     MOV.W   #0x0, &0x458
    138          }
   \   000010   1001         RETA
   \   000012                REQUIRE _A_TB3CCR2_L
   \   000012                REQUIRE _A_TB3CCR1_L
   \   000012                REQUIRE _A_TB3CCR4_L
   \   000012                REQUIRE _A_TB3CCR3_L

   \                                 In  segment CODE, align 2
    139          void Wheels_Process(void){
   \                     Wheels_Process:
    140            //------------------------------------------------------
    141            process_detectors();
   \   000000   ........     CALLA   #process_detectors
    142            switch(state){
   \   000004   5E42....     MOV.B   &state, R14
   \   000008   4E83         SUB.B   #0x0, R14
   \   00000A   0E24         JEQ     ??Wheels_Process_3
   \   00000C   5E83         SUB.B   #0x1, R14
   \   00000E   1624         JEQ     ??Wheels_Process_4
   \   000010   5E83         SUB.B   #0x1, R14
   \   000012   2324         JEQ     ??Wheels_Process_5
   \   000014   5E83         SUB.B   #0x1, R14
   \   000016   2C24         JEQ     ??Wheels_Process_6
   \   000018   5E83         SUB.B   #0x1, R14
   \   00001A   3624         JEQ     ??Wheels_Process_7
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   4F24         JEQ     ??Wheels_Process_8
   \   000020   7E803F00     SUB.B   #0x3f, R14
   \   000024   5C24         JEQ     ??Wheels_Process_1
   \   000026   593C         JMP     ??Wheels_Process_2
    143            case IDLE: // IDLE
    144              stop();
   \                     ??Wheels_Process_3:
   \   000028   ........     CALLA   #stop
    145              set_speed(BASE_SPEED);
   \   00002C   3C408813     MOV.W   #0x1388, R12
   \   000030   ........     CALLA   #set_speed
    146              idle_case(START);
   \   000034   5C43         MOV.B   #0x1, R12
   \   000036   ........     CALLA   #idle_case
    147              break; 
   \   00003A   1001         RETA
    148            case START: 
    149              move(FORWARD);
   \                     ??Wheels_Process_4:
   \   00003C   3C400300     MOV.W   #0x3, R12
   \   000040   ........     CALLA   #move
    150              do_for(&state,IDLE,100);
   \   000044   3E406400     MOV.W   #0x64, R14
   \   000048   4D43         MOV.B   #0x0, R13
   \   00004A   3C40....     MOV.W   #state, R12
   \   00004E   ........     CALLA   #do_for
    151              search(LINE_FOUND);
   \   000052   6C43         MOV.B   #0x2, R12
   \   000054   ........     CALLA   #search
    152              break;
   \   000058   1001         RETA
    153            case LINE_FOUND: 
    154              stop();
   \                     ??Wheels_Process_5:
   \   00005A   ........     CALLA   #stop
    155              do_for(&state,BACK_UP,50);
   \   00005E   3E403200     MOV.W   #0x32, R14
   \   000062   7D400300     MOV.B   #0x3, R13
   \   000066   3C40....     MOV.W   #state, R12
   \   00006A   ........     CALLA   #do_for
    156              //P6OUT |=GRN_LED;
    157              break;
   \   00006E   1001         RETA
    158            case BACK_UP: 
    159              move(FORWARD);
   \                     ??Wheels_Process_6:
   \   000070   3C400300     MOV.W   #0x3, R12
   \   000074   ........     CALLA   #move
    160              do_for(&state,ALIGN,10);
   \   000078   3E400A00     MOV.W   #0xa, R14
   \   00007C   6D42         MOV.B   #0x4, R13
   \   00007E   3C40....     MOV.W   #state, R12
   \   000082   ........     CALLA   #do_for
    161              break;
   \   000086   1001         RETA
    162            case ALIGN: //Spin until both sensor read strong 
    163              
    164              set_speed(BASE_SPEED);
   \                     ??Wheels_Process_7:
   \   000088   3C408813     MOV.W   #0x1388, R12
   \   00008C   ........     CALLA   #set_speed
    165              move(CW);
   \   000090   3C400700     MOV.W   #0x7, R12
   \   000094   ........     CALLA   #move
    166              if(line_detection>=0X44){
   \   000098   B2904400.... CMP.W   #0x44, &line_detection
   \   00009E   0728         JNC     ??Wheels_Process_9
    167                state = PID;
   \   0000A0   F2400500.... MOV.B   #0x5, &state
    168                PIDController_Init(&pid);
   \   0000A6   3C40....     MOV.W   #pid, R12
   \   0000AA   ........     CALLA   #PIDController_Init
    169              }
    170              //check_state=START;
    171              do_for(&state,IDLE,1000);
   \                     ??Wheels_Process_9:
   \   0000AE   3E40E803     MOV.W   #0x3e8, R14
   \   0000B2   4D43         MOV.B   #0x0, R13
   \   0000B4   3C40....     MOV.W   #state, R12
   \   0000B8   ........     CALLA   #do_for
    172              break;
   \   0000BC   1001         RETA
    173            case PID : // Adjust Reverse
    174              move(FORWARD);
   \                     ??Wheels_Process_8:
   \   0000BE   3C400300     MOV.W   #0x3, R12
   \   0000C2   ........     CALLA   #move
    175              pid_control();
   \   0000C6   ........     CALLA   #pid_control
    176              do_for(&state,IDLE,1000);
   \   0000CA   3E40E803     MOV.W   #0x3e8, R14
   \   0000CE   4D43         MOV.B   #0x0, R13
   \   0000D0   3C40....     MOV.W   #state, R12
   \   0000D4   ........     CALLA   #do_for
    177              break;  
   \   0000D8   1001         RETA
    178            case Stop: // Look for End of Stop Time
    179              
    180              break; 
    181            default:
    182              state = IDLE;
   \                     ??Wheels_Process_2:
   \   0000DA   C243....     MOV.B   #0x0, &state
    183              break;
    184            }
    185          }
   \                     ??Wheels_Process_1:
   \   0000DE   1001         RETA

   \                                 In  segment CODE, align 2
    186          void pid_control(){
   \                     pid_control:
   \   000000   1B15         PUSHM.W #0x2, R11
    187            //Want to update pid loop and set output
    188            float Motor_offset = PIDController_Update(&pid,0.0f,measurment());
   \   000002   ........     CALLA   #measurment
   \   000006   0D12         PUSH.W  R13
   \   000008   0C12         PUSH.W  R12
   \   00000A   0E43         MOV.W   #0x0, R14
   \   00000C   0F43         MOV.W   #0x0, R15
   \   00000E   3C40....     MOV.W   #pid, R12
   \   000012   ........     CALLA   #PIDController_Update
   \   000016   0A4C         MOV.W   R12, R10
   \   000018   0B4D         MOV.W   R13, R11
    189            set_left_speed(BASE_SPEED+(unsigned int)Motor_offset);
   \   00001A   0C4A         MOV.W   R10, R12
   \   00001C   0D4B         MOV.W   R11, R13
   \   00001E   ........     CALLA   #_Cast32fto32s
   \   000022   3C508813     ADD.W   #0x1388, R12
   \   000026   ........     CALLA   #set_left_speed
    190            set_right_speed(BASE_SPEED-(unsigned int)Motor_offset);
   \   00002A   3F408813     MOV.W   #0x1388, R15
   \   00002E   0C4A         MOV.W   R10, R12
   \   000030   0D4B         MOV.W   R11, R13
   \   000032   ........     CALLA   #_Cast32fto32s
   \   000036   0F8C         SUB.W   R12, R15
   \   000038   0C4F         MOV.W   R15, R12
   \   00003A   ........     CALLA   #set_right_speed
    191            
    192          }
   \   00003E   A1000400     ADDA    #0x4, SP
   \   000042   1A17         POPM.W  #0x2, R11
   \   000044   1001         RETA
    193          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Wheels_Process
        4   -> PIDController_Init
        4   -> do_for
        4   -> idle_case
        4   -> move
        4   -> pid_control
        4   -> process_detectors
        4   -> search
        4   -> set_speed
        4   -> stop
      6   changed_check
      4   delay_motor
      4   enable_ramp_to
        4   -> ramp_up_to
      4   move
        4   -> changed_check
        4   -> delay_motor
        4   -> process_wheels
     12   pid_control
       12   -> PIDController_Update
        8   -> measurment
       12   -> set_left_speed
       12   -> set_right_speed
       12 _Cast32fto32s
      4   process_wheels
        4   -> stop
      4   ramp_up_to
      4   set_left_speed
      4   set_right_speed
      4   set_speed
      4   stop


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     224  Wheels_Process
       2  _A_TB0CCR2_L
       2  _A_TB0CCTL2_L
       2  _A_TB1CCTL0_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
       2  _A_TB3CCR3_L
       2  _A_TB3CCR4_L
       2  _A_TB3CCR5_L
      66  changed_check
       1  check_state
      94  delay_motor
      16  enable_ramp_to
       2  left_speed
      20  move
      56  pid
      70  pid_control
     122  process_wheels
      12  ramp_up_to
       2  right_speed
       6  set_left_speed
       6  set_right_speed
      10  set_speed
      18  stop

 
 664 bytes in segment CODE
  16 bytes in segment DATA16_AN
  61 bytes in segment DATA16_Z
 
 664 bytes of CODE memory
  61 bytes of DATA memory (+ 16 bytes shared)

Errors: none
Warnings: none
